// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	. "github.com/openclarity/vmclarity/api/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get asset scan estimations according to the given filters
	// (GET /assetScanEstimations)
	GetAssetScanEstimations(ctx echo.Context, params GetAssetScanEstimationsParams) error
	// Create an asset scan estimation for a specified asset
	// (POST /assetScanEstimations)
	PostAssetScanEstimations(ctx echo.Context) error
	// Delete an asset scan estimation.
	// (DELETE /assetScanEstimations/{assetScanEstimationID})
	DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID) error
	// Get an asset scan estimation.
	// (GET /assetScanEstimations/{assetScanEstimationID})
	GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params GetAssetScanEstimationsAssetScanEstimationIDParams) error
	// Patch an asset scan estimation
	// (PATCH /assetScanEstimations/{assetScanEstimationID})
	PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PatchAssetScanEstimationsAssetScanEstimationIDParams) error
	// Update an asset scan estimation.
	// (PUT /assetScanEstimations/{assetScanEstimationID})
	PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PutAssetScanEstimationsAssetScanEstimationIDParams) error
	// Get asset scans according to the given filters
	// (GET /assetScans)
	GetAssetScans(ctx echo.Context, params GetAssetScansParams) error
	// Create an asset scan for a specified asset
	// (POST /assetScans)
	PostAssetScans(ctx echo.Context) error
	// Get an asset scan.
	// (GET /assetScans/{assetScanID})
	GetAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params GetAssetScansAssetScanIDParams) error
	// Patch an asset scan
	// (PATCH /assetScans/{assetScanID})
	PatchAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PatchAssetScansAssetScanIDParams) error
	// Update an asset scan.
	// (PUT /assetScans/{assetScanID})
	PutAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PutAssetScansAssetScanIDParams) error
	// Get assets
	// (GET /assets)
	GetAssets(ctx echo.Context, params GetAssetsParams) error
	// Create asset
	// (POST /assets)
	PostAssets(ctx echo.Context) error
	// Delete asset.
	// (DELETE /assets/{assetID})
	DeleteAssetsAssetID(ctx echo.Context, assetID AssetID) error
	// Get asset.
	// (GET /assets/{assetID})
	GetAssetsAssetID(ctx echo.Context, assetID AssetID, params GetAssetsAssetIDParams) error
	// Update asset.
	// (PATCH /assets/{assetID})
	PatchAssetsAssetID(ctx echo.Context, assetID AssetID, params PatchAssetsAssetIDParams) error
	// Update asset.
	// (PUT /assets/{assetID})
	PutAssetsAssetID(ctx echo.Context, assetID AssetID, params PutAssetsAssetIDParams) error
	// Get all findings.
	// (GET /findings)
	GetFindings(ctx echo.Context, params GetFindingsParams) error
	// Create a finding
	// (POST /findings)
	PostFindings(ctx echo.Context) error
	// Delete a finding.
	// (DELETE /findings/{findingID})
	DeleteFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get the details for a finding.
	// (GET /findings/{findingID})
	GetFindingsFindingID(ctx echo.Context, findingID FindingID, params GetFindingsFindingIDParams) error
	// Patch a finding.
	// (PATCH /findings/{findingID})
	PatchFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Update a finding.
	// (PUT /findings/{findingID})
	PutFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get this OpenAPI spec
	// (GET /openapi.json)
	GetOpenAPISpec(ctx echo.Context) error
	// Get providers
	// (GET /providers)
	GetProviders(ctx echo.Context, params GetProvidersParams) error
	// Create provider
	// (POST /providers)
	PostProviders(ctx echo.Context) error
	// Delete provider.
	// (DELETE /providers/{providerID})
	DeleteProvidersProviderID(ctx echo.Context, providerID ProviderID) error
	// Get provider.
	// (GET /providers/{providerID})
	GetProvidersProviderID(ctx echo.Context, providerID ProviderID, params GetProvidersProviderIDParams) error
	// Update provider.
	// (PATCH /providers/{providerID})
	PatchProvidersProviderID(ctx echo.Context, providerID ProviderID, params PatchProvidersProviderIDParams) error
	// Update provider.
	// (PUT /providers/{providerID})
	PutProvidersProviderID(ctx echo.Context, providerID ProviderID, params PutProvidersProviderIDParams) error
	// Get all scan configs.
	// (GET /scanConfigs)
	GetScanConfigs(ctx echo.Context, params GetScanConfigsParams) error
	// Create a scan config
	// (POST /scanConfigs)
	PostScanConfigs(ctx echo.Context) error
	// Delete a scan config.
	// (DELETE /scanConfigs/{scanConfigID})
	DeleteScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID) error
	// Get the details for a scan config.
	// (GET /scanConfigs/{scanConfigID})
	GetScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params GetScanConfigsScanConfigIDParams) error
	// Patch a scan config.
	// (PATCH /scanConfigs/{scanConfigID})
	PatchScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PatchScanConfigsScanConfigIDParams) error
	// Update a scan config.
	// (PUT /scanConfigs/{scanConfigID})
	PutScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PutScanConfigsScanConfigIDParams) error
	// Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
	// (GET /scanEstimations)
	GetScanEstimations(ctx echo.Context, params GetScanEstimationsParams) error
	// Create a multi-asset scan estimation
	// (POST /scanEstimations)
	PostScanEstimations(ctx echo.Context) error
	// Delete a scan estimation.
	// (DELETE /scanEstimations/{scanEstimationID})
	DeleteScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID) error
	// Get the details for a given multi-asset scan estimation.
	// (GET /scanEstimations/{scanEstimationID})
	GetScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params GetScanEstimationsScanEstimationIDParams) error
	// Patch a scan estimation.
	// (PATCH /scanEstimations/{scanEstimationID})
	PatchScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PatchScanEstimationsScanEstimationIDParams) error
	// Update a scan estimation.
	// (PUT /scanEstimations/{scanEstimationID})
	PutScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PutScanEstimationsScanEstimationIDParams) error
	// Get all scans. Each scan contains details about a multi-asset scheduled scan.
	// (GET /scans)
	GetScans(ctx echo.Context, params GetScansParams) error
	// Create a multi-asset scheduled scan
	// (POST /scans)
	PostScans(ctx echo.Context) error
	// Delete a scan.
	// (DELETE /scans/{scanID})
	DeleteScansScanID(ctx echo.Context, scanID ScanID) error
	// Get the details for a given multi-asset scheduled scan.
	// (GET /scans/{scanID})
	GetScansScanID(ctx echo.Context, scanID ScanID, params GetScansScanIDParams) error
	// Patch a scan.
	// (PATCH /scans/{scanID})
	PatchScansScanID(ctx echo.Context, scanID ScanID, params PatchScansScanIDParams) error
	// Update a scan.
	// (PUT /scans/{scanID})
	PutScansScanID(ctx echo.Context, scanID ScanID, params PutScansScanIDParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimations(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimations(ctx, params)
	return err
}

// PostAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScanEstimations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScanEstimations(ctx)
	return err
}

// DeleteAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID)
	return err
}

// GetAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsAssetScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PatchAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PutAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// GetAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScans(ctx, params)
	return err
}

// PostAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScans(ctx)
	return err
}

// GetAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansAssetScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PatchAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PutAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// GetAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssets(ctx, params)
	return err
}

// PostAssets converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssets(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssets(ctx)
	return err
}

// DeleteAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetsAssetID(ctx, assetID)
	return err
}

// GetAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsAssetIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetsAssetID(ctx, assetID, params)
	return err
}

// PatchAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetsAssetID(ctx, assetID, params)
	return err
}

// PutAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetsAssetID(ctx, assetID, params)
	return err
}

// GetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindings(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindings(ctx, params)
	return err
}

// PostFindings converts echo context to params.
func (w *ServerInterfaceWrapper) PostFindings(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFindings(ctx)
	return err
}

// DeleteFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteFindingsFindingID(ctx, findingID)
	return err
}

// GetFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsFindingIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindingsFindingID(ctx, findingID, params)
	return err
}

// PatchFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchFindingsFindingID(ctx, findingID)
	return err
}

// PutFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PutFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutFindingsFindingID(ctx, findingID)
	return err
}

// GetOpenAPISpec converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenAPISpec(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOpenAPISpec(ctx)
	return err
}

// GetProviders converts echo context to params.
func (w *ServerInterfaceWrapper) GetProviders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProvidersParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProviders(ctx, params)
	return err
}

// PostProviders converts echo context to params.
func (w *ServerInterfaceWrapper) PostProviders(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProviders(ctx)
	return err
}

// DeleteProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProvidersProviderID(ctx, providerID)
	return err
}

// GetProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) GetProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProvidersProviderIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProvidersProviderID(ctx, providerID, params)
	return err
}

// PatchProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchProvidersProviderIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchProvidersProviderID(ctx, providerID, params)
	return err
}

// PutProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) PutProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutProvidersProviderIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutProvidersProviderID(ctx, providerID, params)
	return err
}

// GetScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigs(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigs(ctx, params)
	return err
}

// PostScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanConfigs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanConfigs(ctx)
	return err
}

// DeleteScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanConfigsScanConfigID(ctx, scanConfigID)
	return err
}

// GetScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsScanConfigIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PatchScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PutScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// GetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimations(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimations(ctx, params)
	return err
}

// PostScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanEstimations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanEstimations(ctx)
	return err
}

// DeleteScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanEstimationsScanEstimationID(ctx, scanEstimationID)
	return err
}

// GetScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PatchScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PutScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// GetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScans(ctx, params)
	return err
}

// PostScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScans(ctx)
	return err
}

// DeleteScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScansScanID(ctx, scanID)
	return err
}

// GetScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScansScanID(ctx, scanID, params)
	return err
}

// PatchScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScansScanID(ctx, scanID, params)
	return err
}

// PutScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScansScanID(ctx, scanID, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/assetScanEstimations", wrapper.GetAssetScanEstimations)
	router.POST(baseURL+"/assetScanEstimations", wrapper.PostAssetScanEstimations)
	router.DELETE(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.DeleteAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.GetAssetScanEstimationsAssetScanEstimationID)
	router.PATCH(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PatchAssetScanEstimationsAssetScanEstimationID)
	router.PUT(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PutAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScans", wrapper.GetAssetScans)
	router.POST(baseURL+"/assetScans", wrapper.PostAssetScans)
	router.GET(baseURL+"/assetScans/:assetScanID", wrapper.GetAssetScansAssetScanID)
	router.PATCH(baseURL+"/assetScans/:assetScanID", wrapper.PatchAssetScansAssetScanID)
	router.PUT(baseURL+"/assetScans/:assetScanID", wrapper.PutAssetScansAssetScanID)
	router.GET(baseURL+"/assets", wrapper.GetAssets)
	router.POST(baseURL+"/assets", wrapper.PostAssets)
	router.DELETE(baseURL+"/assets/:assetID", wrapper.DeleteAssetsAssetID)
	router.GET(baseURL+"/assets/:assetID", wrapper.GetAssetsAssetID)
	router.PATCH(baseURL+"/assets/:assetID", wrapper.PatchAssetsAssetID)
	router.PUT(baseURL+"/assets/:assetID", wrapper.PutAssetsAssetID)
	router.GET(baseURL+"/findings", wrapper.GetFindings)
	router.POST(baseURL+"/findings", wrapper.PostFindings)
	router.DELETE(baseURL+"/findings/:findingID", wrapper.DeleteFindingsFindingID)
	router.GET(baseURL+"/findings/:findingID", wrapper.GetFindingsFindingID)
	router.PATCH(baseURL+"/findings/:findingID", wrapper.PatchFindingsFindingID)
	router.PUT(baseURL+"/findings/:findingID", wrapper.PutFindingsFindingID)
	router.GET(baseURL+"/openapi.json", wrapper.GetOpenAPISpec)
	router.GET(baseURL+"/providers", wrapper.GetProviders)
	router.POST(baseURL+"/providers", wrapper.PostProviders)
	router.DELETE(baseURL+"/providers/:providerID", wrapper.DeleteProvidersProviderID)
	router.GET(baseURL+"/providers/:providerID", wrapper.GetProvidersProviderID)
	router.PATCH(baseURL+"/providers/:providerID", wrapper.PatchProvidersProviderID)
	router.PUT(baseURL+"/providers/:providerID", wrapper.PutProvidersProviderID)
	router.GET(baseURL+"/scanConfigs", wrapper.GetScanConfigs)
	router.POST(baseURL+"/scanConfigs", wrapper.PostScanConfigs)
	router.DELETE(baseURL+"/scanConfigs/:scanConfigID", wrapper.DeleteScanConfigsScanConfigID)
	router.GET(baseURL+"/scanConfigs/:scanConfigID", wrapper.GetScanConfigsScanConfigID)
	router.PATCH(baseURL+"/scanConfigs/:scanConfigID", wrapper.PatchScanConfigsScanConfigID)
	router.PUT(baseURL+"/scanConfigs/:scanConfigID", wrapper.PutScanConfigsScanConfigID)
	router.GET(baseURL+"/scanEstimations", wrapper.GetScanEstimations)
	router.POST(baseURL+"/scanEstimations", wrapper.PostScanEstimations)
	router.DELETE(baseURL+"/scanEstimations/:scanEstimationID", wrapper.DeleteScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scanEstimations/:scanEstimationID", wrapper.GetScanEstimationsScanEstimationID)
	router.PATCH(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PatchScanEstimationsScanEstimationID)
	router.PUT(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PutScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scans", wrapper.GetScans)
	router.POST(baseURL+"/scans", wrapper.PostScans)
	router.DELETE(baseURL+"/scans/:scanID", wrapper.DeleteScansScanID)
	router.GET(baseURL+"/scans/:scanID", wrapper.GetScansScanID)
	router.PATCH(baseURL+"/scans/:scanID", wrapper.PatchScansScanID)
	router.PUT(baseURL+"/scans/:scanID", wrapper.PutScansScanID)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"Jb0Bki9f/jsAAP//QyLZXD5lAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
