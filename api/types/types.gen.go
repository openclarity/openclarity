// Package types provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package types

import (
	"encoding/json"
	"errors"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for AssetScanEstimationStatusReason.
const (
	AssetScanEstimationStatusReasonAborted      AssetScanEstimationStatusReason = "Aborted"
	AssetScanEstimationStatusReasonCancellation AssetScanEstimationStatusReason = "Cancellation"
	AssetScanEstimationStatusReasonCreated      AssetScanEstimationStatusReason = "Created"
	AssetScanEstimationStatusReasonError        AssetScanEstimationStatusReason = "Error"
	AssetScanEstimationStatusReasonSuccess      AssetScanEstimationStatusReason = "Success"
)

// Defines values for AssetScanEstimationStatusState.
const (
	AssetScanEstimationStatusStateAborted AssetScanEstimationStatusState = "Aborted"
	AssetScanEstimationStatusStateDone    AssetScanEstimationStatusState = "Done"
	AssetScanEstimationStatusStateFailed  AssetScanEstimationStatusState = "Failed"
	AssetScanEstimationStatusStatePending AssetScanEstimationStatusState = "Pending"
)

// Defines values for AssetScanStatusReason.
const (
	AssetScanStatusReasonAbortTimeout     AssetScanStatusReason = "AbortTimedOut"
	AssetScanStatusReasonCancellation     AssetScanStatusReason = "Cancellation"
	AssetScanStatusReasonCreated          AssetScanStatusReason = "Created"
	AssetScanStatusReasonError            AssetScanStatusReason = "Error"
	AssetScanStatusReasonProvisioning     AssetScanStatusReason = "Provisioning"
	AssetScanStatusReasonResourcesReady   AssetScanStatusReason = "ResourcesReady"
	AssetScanStatusReasonScannerIsRunning AssetScanStatusReason = "ScannerIsRunning"
	AssetScanStatusReasonSuccess          AssetScanStatusReason = "Success"
	AssetScanStatusReasonTimeout          AssetScanStatusReason = "Timeout"
	AssetScanStatusReasonUnSupervised     AssetScanStatusReason = "UnSupervised"
)

// Defines values for AssetScanStatusState.
const (
	AssetScanStatusStateAborted     AssetScanStatusState = "Aborted"
	AssetScanStatusStateDone        AssetScanStatusState = "Done"
	AssetScanStatusStateFailed      AssetScanStatusState = "Failed"
	AssetScanStatusStateInProgress  AssetScanStatusState = "InProgress"
	AssetScanStatusStatePending     AssetScanStatusState = "Pending"
	AssetScanStatusStateReadyToScan AssetScanStatusState = "ReadyToScan"
	AssetScanStatusStateScheduled   AssetScanStatusState = "Scheduled"
)

// Defines values for CloudProvider.
const (
	AWS        CloudProvider = "AWS"
	Azure      CloudProvider = "Azure"
	Docker     CloudProvider = "Docker"
	External   CloudProvider = "External"
	GCP        CloudProvider = "GCP"
	Kubernetes CloudProvider = "Kubernetes"
)

// Defines values for InfoType.
const (
	InfoTypeSSHAuthorizedKeyFingerprint InfoType = "SSHAuthorizedKeyFingerprint"
	InfoTypeSSHDaemonKeyFingerprint     InfoType = "SSHDaemonKeyFingerprint"
	InfoTypeSSHKnownHostFingerprint     InfoType = "SSHKnownHostFingerprint"
	InfoTypeSSHPrivateKeyFingerprint    InfoType = "SSHPrivateKeyFingerprint"
	InfoTypeUNKNOWN                     InfoType = "UNKNOWN"
)

// Defines values for MisconfigurationSeverity.
const (
	MisconfigurationHighSeverity   MisconfigurationSeverity = "MisconfigurationHighSeverity"
	MisconfigurationInfoSeverity   MisconfigurationSeverity = "MisconfigurationInfoSeverity"
	MisconfigurationLowSeverity    MisconfigurationSeverity = "MisconfigurationLowSeverity"
	MisconfigurationMediumSeverity MisconfigurationSeverity = "MisconfigurationMediumSeverity"
)

// Defines values for ProviderStatusReason.
const (
	HeartbeatReceived   ProviderStatusReason = "HeartbeatReceived"
	NoHeartbeatReceived ProviderStatusReason = "NoHeartbeatReceived"
)

// Defines values for ProviderStatusState.
const (
	ProviderStatusStateHealthy   ProviderStatusState = "Healthy"
	ProviderStatusStateUnhealthy ProviderStatusState = "Unhealthy"
	ProviderStatusStateUnknown   ProviderStatusState = "Unknown"
)

// Defines values for ResourceCleanupStatusReason.
const (
	ResourceCleanupStatusReasonAssetScanCreated ResourceCleanupStatusReason = "AssetScanCreated"
	ResourceCleanupStatusReasonDeletePolicy     ResourceCleanupStatusReason = "DeletePolicy"
	ResourceCleanupStatusReasonInternalError    ResourceCleanupStatusReason = "InternalError"
	ResourceCleanupStatusReasonNotApplicable    ResourceCleanupStatusReason = "NotApplicable"
	ResourceCleanupStatusReasonProviderError    ResourceCleanupStatusReason = "ProviderError"
	ResourceCleanupStatusReasonSuccess          ResourceCleanupStatusReason = "Success"
)

// Defines values for ResourceCleanupStatusState.
const (
	ResourceCleanupStatusStateDone    ResourceCleanupStatusState = "Done"
	ResourceCleanupStatusStateFailed  ResourceCleanupStatusState = "Failed"
	ResourceCleanupStatusStatePending ResourceCleanupStatusState = "Pending"
	ResourceCleanupStatusStateSkipped ResourceCleanupStatusState = "Skipped"
)

// Defines values for RootVolumeEncrypted.
const (
	RootVolumeEncryptedNo      RootVolumeEncrypted = "No"
	RootVolumeEncryptedUnknown RootVolumeEncrypted = "Unknown"
	RootVolumeEncryptedYes     RootVolumeEncrypted = "Yes"
)

// Defines values for RootkitType.
const (
	RootkitTypeAPPLICATION RootkitType = "APPLICATION"
	RootkitTypeFIRMWARE    RootkitType = "FIRMWARE"
	RootkitTypeKERNEL      RootkitType = "KERNEL"
	RootkitTypeMEMORY      RootkitType = "MEMORY"
	RootkitTypeUNKNOWN     RootkitType = "UNKNOWN"
)

// Defines values for ScanEstimationStatusReason.
const (
	ScanEstimationStatusReasonAborted             ScanEstimationStatusReason = "Aborted"
	ScanEstimationStatusReasonCancellation        ScanEstimationStatusReason = "Cancellation"
	ScanEstimationStatusReasonCreated             ScanEstimationStatusReason = "Created"
	ScanEstimationStatusReasonError               ScanEstimationStatusReason = "Error"
	ScanEstimationStatusReasonNothingToEstimate   ScanEstimationStatusReason = "NothingToEstimate"
	ScanEstimationStatusReasonRunning             ScanEstimationStatusReason = "EstimationsRunning"
	ScanEstimationStatusReasonSuccess             ScanEstimationStatusReason = "Success"
	ScanEstimationStatusReasonSuccessfulDiscovery ScanEstimationStatusReason = "SuccessfulDiscovery"
	ScanEstimationStatusReasonTimeout             ScanEstimationStatusReason = "TimeOut"
)

// Defines values for ScanEstimationStatusState.
const (
	ScanEstimationStatusStateAborted    ScanEstimationStatusState = "Aborted"
	ScanEstimationStatusStateDiscovered ScanEstimationStatusState = "Discovered"
	ScanEstimationStatusStateDone       ScanEstimationStatusState = "Done"
	ScanEstimationStatusStateFailed     ScanEstimationStatusState = "Failed"
	ScanEstimationStatusStateInProgress ScanEstimationStatusState = "InProgress"
	ScanEstimationStatusStatePending    ScanEstimationStatusState = "Pending"
)

// Defines values for ScanStatusReason.
const (
	ScanStatusReasonAssetScansRunning ScanStatusReason = "AssetScansRunning"
	ScanStatusReasonAssetsDiscovered  ScanStatusReason = "AssetsDiscovered"
	ScanStatusReasonCancellation      ScanStatusReason = "Cancellation"
	ScanStatusReasonCreated           ScanStatusReason = "Created"
	ScanStatusReasonError             ScanStatusReason = "Error"
	ScanStatusReasonNothingToScan     ScanStatusReason = "NothingToScan"
	ScanStatusReasonSuccess           ScanStatusReason = "Success"
	ScanStatusReasonTimeout           ScanStatusReason = "Timeout"
)

// Defines values for ScanStatusState.
const (
	ScanStatusStateAborted    ScanStatusState = "Aborted"
	ScanStatusStateDiscovered ScanStatusState = "Discovered"
	ScanStatusStateDone       ScanStatusState = "Done"
	ScanStatusStateFailed     ScanStatusState = "Failed"
	ScanStatusStateInProgress ScanStatusState = "InProgress"
	ScanStatusStatePending    ScanStatusState = "Pending"
)

// Defines values for ScanType.
const (
	EXPLOIT          ScanType = "EXPLOIT"
	INFOFINDER       ScanType = "INFOFINDER"
	MALWARE          ScanType = "MALWARE"
	MISCONFIGURATION ScanType = "MISCONFIGURATION"
	ROOTKIT          ScanType = "ROOTKIT"
	SBOM             ScanType = "SBOM"
	SECRET           ScanType = "SECRET"
	VULNERABILITY    ScanType = "VULNERABILITY"
)

// Defines values for ScannerStatusReason.
const (
	ScannerStatusReasonError        ScannerStatusReason = "Error"
	ScannerStatusReasonNotScheduled ScannerStatusReason = "NotScheduled"
	ScannerStatusReasonScanning     ScannerStatusReason = "Scanning"
	ScannerStatusReasonScheduled    ScannerStatusReason = "Scheduled"
	ScannerStatusReasonSuccess      ScannerStatusReason = "Success"
)

// Defines values for ScannerStatusState.
const (
	ScannerStatusStateDone       ScannerStatusState = "Done"
	ScannerStatusStateFailed     ScannerStatusState = "Failed"
	ScannerStatusStateInProgress ScannerStatusState = "InProgress"
	ScannerStatusStatePending    ScannerStatusState = "Pending"
	ScannerStatusStateSkipped    ScannerStatusState = "Skipped"
)

// Defines values for VulnerabilitySeverity.
const (
	CRITICAL   VulnerabilitySeverity = "CRITICAL"
	HIGH       VulnerabilitySeverity = "HIGH"
	LOW        VulnerabilitySeverity = "LOW"
	MEDIUM     VulnerabilitySeverity = "MEDIUM"
	NEGLIGIBLE VulnerabilitySeverity = "NEGLIGIBLE"
)

// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
type Annotations = []struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// ApiResponse An object that is returned in all cases of failures.
type ApiResponse struct {
	Message *string `json:"message,omitempty"`
}

// Asset defines model for Asset.
type Asset struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`
	AssetInfo   *AssetType   `json:"assetInfo,omitempty"`
	FirstSeen   *time.Time   `json:"firstSeen,omitempty"`
	Id          *string      `json:"id,omitempty"`
	LastSeen    *time.Time   `json:"lastSeen,omitempty"`

	// Providers List of providers which discover the asset.
	Providers *[]ProviderRelationship `json:"providers,omitempty"`
	Revision  *int                    `json:"revision,omitempty"`

	// ScansCount Total number of scans that have ever run for this asset
	ScansCount *int `json:"scansCount,omitempty"`

	// Summary A summary of the scan findings.
	Summary      *ScanFindingsSummary `json:"summary,omitempty"`
	TerminatedOn *time.Time           `json:"terminatedOn,omitempty"`
}

// AssetCommon defines model for AssetCommon.
type AssetCommon = map[string]interface{}

// AssetExists defines model for AssetExists.
type AssetExists struct {
	// Asset Describes an asset object.
	Asset *Asset `json:"asset,omitempty"`

	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`
}

// AssetFinding defines model for AssetFinding.
type AssetFinding struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Asset Describes a relationship to an asset which can be expanded.
	Asset   *AssetRelationship   `json:"asset,omitempty"`
	Finding *FindingRelationship `json:"finding,omitempty"`

	// FirstSeen When this asset finding was first discovered by a scan
	FirstSeen *time.Time `json:"firstSeen,omitempty"`
	Id        *string    `json:"id,omitempty"`

	// InvalidatedOn When this asset finding was invalidated by a newer scan
	InvalidatedOn *time.Time `json:"invalidatedOn,omitempty"`

	// LastSeen When this asset finding was last discovered by a scan
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	Revision *int       `json:"revision,omitempty"`
}

// AssetFindingExists defines model for AssetFindingExists.
type AssetFindingExists struct {
	Finding *AssetFinding `json:"finding,omitempty"`

	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`
}

// AssetFindings defines model for AssetFindings.
type AssetFindings struct {
	// Count Total asset findings count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of asset findings according to the given filters
	Items *[]AssetFinding `json:"items,omitempty"`
}

// AssetRelationship defines model for AssetRelationship.
type AssetRelationship struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`
	AssetInfo   *AssetType   `json:"assetInfo,omitempty"`
	FirstSeen   *time.Time   `json:"firstSeen,omitempty"`
	Id          string       `json:"id"`
	LastSeen    *time.Time   `json:"lastSeen,omitempty"`

	// Providers List of providers which discover the asset.
	Providers *[]ProviderRelationship `json:"providers,omitempty"`
	Revision  *int                    `json:"revision,omitempty"`

	// ScansCount Total number of scans that have ever run for this asset
	ScansCount *int `json:"scansCount,omitempty"`

	// Summary A summary of the scan findings.
	Summary      *ScanFindingsSummary `json:"summary,omitempty"`
	TerminatedOn *time.Time           `json:"terminatedOn,omitempty"`
}

// AssetScan defines model for AssetScan.
type AssetScan struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Asset Describes a relationship to an asset which can be expanded.
	Asset             *AssetRelationship    `json:"asset,omitempty"`
	Exploits          *ExploitScan          `json:"exploits,omitempty"`
	FindingsProcessed *bool                 `json:"findingsProcessed,omitempty"`
	Id                *string               `json:"id,omitempty"`
	InfoFinder        *InfoFinderScan       `json:"infoFinder,omitempty"`
	Malware           *MalwareScan          `json:"malware,omitempty"`
	Misconfigurations *MisconfigurationScan `json:"misconfigurations,omitempty"`
	Plugins           *PluginScan           `json:"plugins,omitempty"`

	// Provider Describes a relationship to a provider which can be expanded.
	Provider              *ProviderRelationship  `json:"provider,omitempty"`
	ResourceCleanupStatus *ResourceCleanupStatus `json:"resourceCleanupStatus,omitempty"`
	Revision              *int                   `json:"revision,omitempty"`
	Rootkits              *RootkitScan           `json:"rootkits,omitempty"`
	Sbom                  *SbomScan              `json:"sbom,omitempty"`

	// Scan Describes an expandable relationship to Scan object
	Scan *ScanRelationship `json:"scan,omitempty"`

	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig `json:"scanFamiliesConfig,omitempty"`

	// ScannerInstanceCreationConfig Configuration of scanner instance
	ScannerInstanceCreationConfig *ScannerInstanceCreationConfig `json:"scannerInstanceCreationConfig,omitempty"`
	Secrets                       *SecretScan                    `json:"secrets,omitempty"`
	Stats                         *AssetScanStats                `json:"stats,omitempty"`
	Status                        *AssetScanStatus               `json:"status,omitempty"`

	// Summary A summary of the scan findings.
	Summary         *ScanFindingsSummary `json:"summary,omitempty"`
	Vulnerabilities *VulnerabilityScan   `json:"vulnerabilities,omitempty"`
}

// AssetScanEstimation defines model for AssetScanEstimation.
type AssetScanEstimation struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Asset Describes a relationship to an asset which can be expanded.
	Asset             *AssetRelationship `json:"asset,omitempty"`
	AssetScanTemplate *AssetScanTemplate `json:"assetScanTemplate,omitempty"`

	// DeleteAfter The time this resource should be deleted. This value is calculated by endTime + ttlSecondsAfterFinished. This should not be set by the user, but use ttlSecondsAfterFinished instead.
	DeleteAfter    *time.Time                  `json:"deleteAfter,omitempty"`
	EndTime        *time.Time                  `json:"endTime,omitempty"`
	Estimation     *Estimation                 `json:"estimation,omitempty"`
	Id             *string                     `json:"id,omitempty"`
	Revision       *int                        `json:"revision,omitempty"`
	ScanEstimation *ScanEstimationRelationship `json:"scanEstimation,omitempty"`
	StartTime      *time.Time                  `json:"startTime,omitempty"`
	Status         *AssetScanEstimationStatus  `json:"status,omitempty"`

	// TTLSecondsAfterFinished The duration in seconds this resource should last until it is deleted.
	TTLSecondsAfterFinished *int `json:"ttlSecondsAfterFinished,omitempty"`
}

// AssetScanEstimationExists defines model for AssetScanEstimationExists.
type AssetScanEstimationExists struct {
	AssetScanEstimation *AssetScanEstimation `json:"assetScanEstimation,omitempty"`

	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`
}

// AssetScanEstimationRelationship defines model for AssetScanEstimationRelationship.
type AssetScanEstimationRelationship struct {
	Id *string `json:"id,omitempty"`
}

// AssetScanEstimationStatus defines model for AssetScanEstimationStatus.
type AssetScanEstimationStatus struct {
	// LastTransitionTime Last date time when the status has changed.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message Human readable message.
	Message *string `json:"message,omitempty"`

	// Reason Machine readable reason for state transition.
	//
	// | State   | Reason       | Description                                                      |
	// | ------- | ------------ | ---------------------------------------------------------------- |
	// | Pending | Created      | AssetScanEstimation is pending as it has been newly created      |
	// | Aborted | Cancellation | AssetScanEstimation has been aborted due to cancellation request |
	// | Failed  | Aborted      | AssetScanEstimation has failed due to abort                      |
	// | Failed  | Error        | AssetScanEstimation has failed due to an error                   |
	// | Done    | Success      | AssetScanEstimation has finished successfully                    |
	Reason AssetScanEstimationStatusReason `json:"reason"`

	// State Describes the state of asset scan estimation.
	//
	// | State   | Description                                   |
	// | ------- | --------------------------------------------- |
	// | Pending | Initial state for AssetScanEstimation         |
	// | Aborted | AssetScanEstimation has been aborted          |
	// | Failed  | AssetScanEstimation has been failed           |
	// | Done    | AssetScanEstimation has finished successfully |
	State AssetScanEstimationStatusState `json:"state"`
}

// AssetScanEstimationStatusReason Machine readable reason for state transition.
//
// | State   | Reason       | Description                                                      |
// | ------- | ------------ | ---------------------------------------------------------------- |
// | Pending | Created      | AssetScanEstimation is pending as it has been newly created      |
// | Aborted | Cancellation | AssetScanEstimation has been aborted due to cancellation request |
// | Failed  | Aborted      | AssetScanEstimation has failed due to abort                      |
// | Failed  | Error        | AssetScanEstimation has failed due to an error                   |
// | Done    | Success      | AssetScanEstimation has finished successfully                    |
type AssetScanEstimationStatusReason string

// AssetScanEstimationStatusState Describes the state of asset scan estimation.
//
// | State   | Description                                   |
// | ------- | --------------------------------------------- |
// | Pending | Initial state for AssetScanEstimation         |
// | Aborted | AssetScanEstimation has been aborted          |
// | Failed  | AssetScanEstimation has been failed           |
// | Done    | AssetScanEstimation has finished successfully |
type AssetScanEstimationStatusState string

// AssetScanEstimations defines model for AssetScanEstimations.
type AssetScanEstimations struct {
	// Count Total AssetScanEstimations count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of AssetScanEstimations according to the given filters
	Items *[]AssetScanEstimation `json:"items,omitempty"`
}

// AssetScanExists defines model for AssetScanExists.
type AssetScanExists struct {
	AssetScan *AssetScan `json:"assetScan,omitempty"`

	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`
}

// AssetScanGeneralStats Global statistics for asset scan of all families.
type AssetScanGeneralStats struct {
	ScanTime *AssetScanScanTime `json:"scanTime,omitempty"`
}

// AssetScanInputScanStats Statistics per asset scan input.
type AssetScanInputScanStats struct {
	// Path The input path (/mnt/snapshot for ex.)
	Path     *string            `json:"path,omitempty"`
	ScanTime *AssetScanScanTime `json:"scanTime,omitempty"`

	// Size The input size in MB.
	Size *int64 `json:"size,omitempty"`

	// Type The input type (ROOTFS, DIR, IMAGE etc.)
	Type *string `json:"type,omitempty"`
}

// AssetScanRelationship defines model for AssetScanRelationship.
type AssetScanRelationship struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Asset Describes a relationship to an asset which can be expanded.
	Asset                 *AssetRelationship     `json:"asset,omitempty"`
	Exploits              *ExploitScan           `json:"exploits,omitempty"`
	FindingsProcessed     *bool                  `json:"findingsProcessed,omitempty"`
	Id                    string                 `json:"id"`
	InfoFinder            *InfoFinderScan        `json:"infoFinder,omitempty"`
	Malware               *MalwareScan           `json:"malware,omitempty"`
	Misconfigurations     *MisconfigurationScan  `json:"misconfigurations,omitempty"`
	ResourceCleanupStatus *ResourceCleanupStatus `json:"resourceCleanupStatus,omitempty"`
	Revision              *int                   `json:"revision,omitempty"`
	Rootkits              *RootkitScan           `json:"rootkits,omitempty"`
	Sbom                  *SbomScan              `json:"sbom,omitempty"`

	// Scan Describes an expandable relationship to Scan object
	Scan *ScanRelationship `json:"scan,omitempty"`

	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig `json:"scanFamiliesConfig,omitempty"`

	// ScannerInstanceCreationConfig Configuration of scanner instance
	ScannerInstanceCreationConfig *ScannerInstanceCreationConfig `json:"scannerInstanceCreationConfig,omitempty"`
	Secrets                       *SecretScan                    `json:"secrets,omitempty"`
	Stats                         *AssetScanStats                `json:"stats,omitempty"`
	Status                        *AssetScanStatus               `json:"status,omitempty"`

	// Summary A summary of the scan findings.
	Summary         *ScanFindingsSummary `json:"summary,omitempty"`
	Vulnerabilities *VulnerabilityScan   `json:"vulnerabilities,omitempty"`
}

// AssetScanScanTime defines model for AssetScanScanTime.
type AssetScanScanTime struct {
	EndTime   *time.Time `json:"endTime,omitempty"`
	StartTime *time.Time `json:"startTime,omitempty"`
}

// AssetScanStats defines model for AssetScanStats.
type AssetScanStats struct {
	Exploits *[]AssetScanInputScanStats `json:"exploits,omitempty"`

	// General Global statistics for asset scan of all families.
	General           *AssetScanGeneralStats     `json:"general,omitempty"`
	InfoFinder        *[]AssetScanInputScanStats `json:"infoFinder,omitempty"`
	Malware           *[]AssetScanInputScanStats `json:"malware,omitempty"`
	Misconfigurations *[]AssetScanInputScanStats `json:"misconfigurations,omitempty"`
	Plugins           *[]AssetScanInputScanStats `json:"plugins,omitempty"`
	Rootkits          *[]AssetScanInputScanStats `json:"rootkits,omitempty"`
	Sbom              *[]AssetScanInputScanStats `json:"sbom,omitempty"`
	Secrets           *[]AssetScanInputScanStats `json:"secrets,omitempty"`
	Vulnerabilities   *[]AssetScanInputScanStats `json:"vulnerabilities,omitempty"`
}

// AssetScanStatus defines model for AssetScanStatus.
type AssetScanStatus struct {
	// LastTransitionTime Last date time when the status has changed.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message Human readable message.
	Message *string `json:"message,omitempty"`

	// Reason Machine readable reason for state transition.
	//
	// | State       | Reason           | Description                                                                                |
	// | ----------- | ---------------- | ------------------------------------------------------------------------------------------ |
	// | Pending     | Created          | Scan is pending as it has been newly created                                               |
	// | Scheduled   | Provisioning     | Scan is scheduled as Asset resources are being provisioned                                 |
	// | ReadyToScan | UnSupervised     | Scan is created manually without the involvement of the Orchestrator (e.g. CI/CD scenario) |
	// | ReadyToScan | ResourcesReady   | Scan is ready to scan as Asset resources have been provisioned                             |
	// | InProgress  | ScannerIsRunning | Scan is in progress as Scanner is still performing scanning on Asset resources             |
	// | Aborted     | Cancellation     | Scan has been aborted due to cancellation request                                          |
	// | Aborted     | Timeout          | Scan has been aborted due to timeout                                                       |
	// | Failed      | Error            | Scan has failed to one or more errors reported by the Scanner                              |
	// | Failed      | AbortTimeout     | Scan has failed due to being in Aborted state for too long                                 |
	// | Done        | Success          | Scan has finished successfully                                                             |
	Reason AssetScanStatusReason `json:"reason"`

	// State Describes the state of scan result.
	//
	// | State       | Description                                                                                      |
	// | ----------- | ------------------------------------------------------------------------------------------------ |
	// | Pending     | Initial state for AssetScan waiting for being scheduled                                          |
	// | Scheduled   | AssetScan which has been scheduled on Provider                                                   |
	// | ReadyToScan | Provider acknowledged that scanners for AssetScan is ready to run                                |
	// | InProgress  | Scanners are running on the Target                                                               |
	// | Aborted     | AssetScan has been aborted and all running Scanners need to be cancelled and shutdown gracefully |
	// | Failed      | Running Scanners on Target has failed, check *reason* and *message* fields for the details       |
	// | Done        | Running Scanners on Target has finished with no errors                                           |
	State AssetScanStatusState `json:"state"`
}

// AssetScanStatusReason Machine readable reason for state transition.
//
// | State       | Reason           | Description                                                                                |
// | ----------- | ---------------- | ------------------------------------------------------------------------------------------ |
// | Pending     | Created          | Scan is pending as it has been newly created                                               |
// | Scheduled   | Provisioning     | Scan is scheduled as Asset resources are being provisioned                                 |
// | ReadyToScan | UnSupervised     | Scan is created manually without the involvement of the Orchestrator (e.g. CI/CD scenario) |
// | ReadyToScan | ResourcesReady   | Scan is ready to scan as Asset resources have been provisioned                             |
// | InProgress  | ScannerIsRunning | Scan is in progress as Scanner is still performing scanning on Asset resources             |
// | Aborted     | Cancellation     | Scan has been aborted due to cancellation request                                          |
// | Aborted     | Timeout          | Scan has been aborted due to timeout                                                       |
// | Failed      | Error            | Scan has failed to one or more errors reported by the Scanner                              |
// | Failed      | AbortTimeout     | Scan has failed due to being in Aborted state for too long                                 |
// | Done        | Success          | Scan has finished successfully                                                             |
type AssetScanStatusReason string

// AssetScanStatusState Describes the state of scan result.
//
// | State       | Description                                                                                      |
// | ----------- | ------------------------------------------------------------------------------------------------ |
// | Pending     | Initial state for AssetScan waiting for being scheduled                                          |
// | Scheduled   | AssetScan which has been scheduled on Provider                                                   |
// | ReadyToScan | Provider acknowledged that scanners for AssetScan is ready to run                                |
// | InProgress  | Scanners are running on the Target                                                               |
// | Aborted     | AssetScan has been aborted and all running Scanners need to be cancelled and shutdown gracefully |
// | Failed      | Running Scanners on Target has failed, check *reason* and *message* fields for the details       |
// | Done        | Running Scanners on Target has finished with no errors                                           |
type AssetScanStatusState string

// AssetScanTemplate defines model for AssetScanTemplate.
type AssetScanTemplate struct {
	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig `json:"scanFamiliesConfig,omitempty"`

	// ScannerInstanceCreationConfig Configuration of scanner instance
	ScannerInstanceCreationConfig *ScannerInstanceCreationConfig `json:"scannerInstanceCreationConfig,omitempty"`
}

// AssetScanTemplateReadOnly defines model for AssetScanTemplateReadOnly.
type AssetScanTemplateReadOnly struct {
	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig `json:"scanFamiliesConfig,omitempty"`

	// ScannerInstanceCreationConfig Configuration of scanner instance
	ScannerInstanceCreationConfig *ScannerInstanceCreationConfig `json:"scannerInstanceCreationConfig,omitempty"`
}

// AssetScans defines model for AssetScans.
type AssetScans struct {
	// Count Total asset scans count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of asset scans according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]AssetScan `json:"items,omitempty"`
}

// AssetType defines model for AssetType.
type AssetType struct {
	union json.RawMessage
}

// Assets defines model for Assets.
type Assets struct {
	// Count Total assets count according the given filters
	Count *int `json:"count,omitempty"`

	// Items List of assets in the given filters and page. List length must be lower or equal to pageSize.
	Items *[]Asset `json:"items,omitempty"`
}

// CloudProvider defines model for CloudProvider.
type CloudProvider string

// ContainerImageInfo defines model for ContainerImageInfo.
type ContainerImageInfo struct {
	Architecture *string   `json:"architecture,omitempty"`
	ImageID      string    `json:"imageID"`
	Labels       *[]Tag    `json:"labels"`
	ObjectType   string    `json:"objectType"`
	Os           *string   `json:"os,omitempty"`
	RepoDigests  *[]string `json:"repoDigests,omitempty"`
	RepoTags     *[]string `json:"repoTags,omitempty"`
	Size         *int64    `json:"size,omitempty"`
}

// ContainerInfo defines model for ContainerInfo.
type ContainerInfo struct {
	ContainerID   string              `json:"containerID"`
	ContainerName *string             `json:"containerName,omitempty"`
	CreatedAt     *time.Time          `json:"createdAt,omitempty"`
	Image         *ContainerImageInfo `json:"image,omitempty"`
	Labels        *[]Tag              `json:"labels"`
	Location      *string             `json:"location,omitempty"`
	ObjectType    string              `json:"objectType"`
}

// CostBreakdownComponent defines model for CostBreakdownComponent.
type CostBreakdownComponent struct {
	Cost      float32 `json:"cost"`
	Operation string  `json:"operation"`
}

// DirInfo defines model for DirInfo.
type DirInfo struct {
	DirName    *string `json:"dirName,omitempty"`
	Location   *string `json:"location,omitempty"`
	ObjectType string  `json:"objectType"`
}

// Estimation defines model for Estimation.
type Estimation struct {
	// Cost The estimated scan cost ($)
	Cost          *float32                  `json:"cost,omitempty"`
	CostBreakdown *[]CostBreakdownComponent `json:"costBreakdown,omitempty"`

	// Duration The estimated scan duration (seconds)
	Duration *int `json:"duration,omitempty"`

	// Size The estimated scan size (GB)
	Size *int `json:"size,omitempty"`
}

// Exploit defines model for Exploit.
type Exploit struct {
	CveID       *string   `json:"cveID,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	SourceDB    *string   `json:"sourceDB,omitempty"`
	Title       *string   `json:"title,omitempty"`
	Urls        *[]string `json:"urls"`
}

// ExploitFindingInfo defines model for ExploitFindingInfo.
type ExploitFindingInfo struct {
	CveID       *string   `json:"cveID,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	ObjectType  string    `json:"objectType"`
	SourceDB    *string   `json:"sourceDB,omitempty"`
	Title       *string   `json:"title,omitempty"`
	Urls        *[]string `json:"urls"`
}

// ExploitScan defines model for ExploitScan.
type ExploitScan struct {
	Exploits *[]Exploit     `json:"exploits"`
	Status   *ScannerStatus `json:"status,omitempty"`
}

// ExploitsConfig defines model for ExploitsConfig.
type ExploitsConfig struct {
	Enabled  *bool     `json:"enabled,omitempty"`
	Scanners *[]string `json:"scanners,omitempty"`
}

// Finding defines model for Finding.
type Finding struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`
	FindingInfo *FindingInfo `json:"findingInfo,omitempty"`

	// FirstSeen When this finding was first discovered by a scan
	FirstSeen *time.Time `json:"firstSeen,omitempty"`
	Id        *string    `json:"id,omitempty"`

	// LastSeen When this finding was last discovered by a scan
	LastSeen   *time.Time             `json:"lastSeen,omitempty"`
	LastSeenBy *AssetScanRelationship `json:"lastSeenBy,omitempty"`
	Revision   *int                   `json:"revision,omitempty"`
	Summary    *FindingSummary        `json:"summary,omitempty"`
}

// FindingExists defines model for FindingExists.
type FindingExists struct {
	Finding *Finding `json:"finding,omitempty"`

	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`
}

// FindingInfo defines model for FindingInfo.
type FindingInfo struct {
	union json.RawMessage
}

// FindingRelationship defines model for FindingRelationship.
type FindingRelationship struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`
	FindingInfo *FindingInfo `json:"findingInfo,omitempty"`

	// FirstSeen When this finding was first discovered by a scan
	FirstSeen *time.Time `json:"firstSeen,omitempty"`
	Id        string     `json:"id"`

	// LastSeen When this finding was last discovered by a scan
	LastSeen   *time.Time             `json:"lastSeen,omitempty"`
	LastSeenBy *AssetScanRelationship `json:"lastSeenBy,omitempty"`
	Revision   *int                   `json:"revision,omitempty"`
	Summary    *FindingSummary        `json:"summary,omitempty"`
}

// FindingSummary defines model for FindingSummary.
type FindingSummary struct {
	// TotalVulnerabilities A summary of number of vulnerabilities found per severity.
	TotalVulnerabilities *VulnerabilitySeveritySummary `json:"totalVulnerabilities,omitempty"`
	UpdatedAt            *string                       `json:"updatedAt,omitempty"`
}

// Findings defines model for Findings.
type Findings struct {
	// Count Total findings count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of findings according to the given filters
	Items *[]Finding `json:"items,omitempty"`
}

// InfoFinderConfig defines model for InfoFinderConfig.
type InfoFinderConfig struct {
	Enabled  *bool     `json:"enabled,omitempty"`
	Scanners *[]string `json:"scanners,omitempty"`
}

// InfoFinderFindingInfo defines model for InfoFinderFindingInfo.
type InfoFinderFindingInfo struct {
	// Data The data found by the scanner in the specific path for a specific type. See example for SSHKnownHostFingerprint info type
	Data       *string `json:"data,omitempty"`
	ObjectType string  `json:"objectType"`

	// Path File path containing the info
	Path        *string   `json:"path,omitempty"`
	ScannerName *string   `json:"scannerName,omitempty"`
	Type        *InfoType `json:"type,omitempty"`
}

// InfoFinderInfo defines model for InfoFinderInfo.
type InfoFinderInfo struct {
	// Data The data found by the scanner in the specific path for a specific type. See example for SSHKnownHostFingerprint info type
	Data *string `json:"data,omitempty"`

	// Path File path containing the info
	Path        *string   `json:"path,omitempty"`
	ScannerName *string   `json:"scannerName,omitempty"`
	Type        *InfoType `json:"type,omitempty"`
}

// InfoFinderScan defines model for InfoFinderScan.
type InfoFinderScan struct {
	Infos    *[]InfoFinderInfo `json:"infos"`
	Scanners *[]string         `json:"scanners"`
	Status   *ScannerStatus    `json:"status,omitempty"`
}

// InfoType defines model for InfoType.
type InfoType string

// Malware defines model for Malware.
type Malware struct {
	MalwareName *string      `json:"malwareName,omitempty"`
	MalwareType *MalwareType `json:"malwareType,omitempty"`

	// Path Path of the file that contains malware
	Path     *string `json:"path,omitempty"`
	RuleName *string `json:"ruleName,omitempty"`
}

// MalwareConfig defines model for MalwareConfig.
type MalwareConfig struct {
	Enabled               *bool     `json:"enabled,omitempty"`
	Scanners              *[]string `json:"scanners,omitempty"`
	YaraDirectoriesToScan *[]string `json:"yara_directories_to_scan,omitempty"`
}

// MalwareFindingInfo defines model for MalwareFindingInfo.
type MalwareFindingInfo struct {
	MalwareName *string      `json:"malwareName,omitempty"`
	MalwareType *MalwareType `json:"malwareType,omitempty"`
	ObjectType  string       `json:"objectType"`

	// Path Path of the file that contains malware
	Path     *string `json:"path,omitempty"`
	RuleName *string `json:"ruleName,omitempty"`
}

// MalwareScan defines model for MalwareScan.
type MalwareScan struct {
	Malware  *[]Malware         `json:"malware"`
	Metadata *[]ScannerMetadata `json:"metadata"`
	Status   *ScannerStatus     `json:"status,omitempty"`
}

// MalwareType defines model for MalwareType.
type MalwareType = string

// Metadata defines model for Metadata.
type Metadata struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`
}

// MetadataReadOnly defines model for MetadataReadOnly.
type MetadataReadOnly struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`
}

// Misconfiguration defines model for Misconfiguration.
type Misconfiguration struct {
	// Category Specifies misconfiguration impact category
	Category *string `json:"category,omitempty"`

	// Description Additional context such as the potential impact
	Description *string `json:"description,omitempty"`

	// Id Check or test ID, if applicable (e.g. Lynis TestID, CIS Docker Benchmark checkpoint code, etc)
	Id *string `json:"id,omitempty"`

	// Location Location within the asset where the misconfiguration was recorded (e.g. filesystem path)
	Location *string `json:"location,omitempty"`

	// Message Short info about the misconfiguration
	Message *string `json:"message,omitempty"`

	// Remediation Possible fix for the misconfiguration
	Remediation *string                   `json:"remediation,omitempty"`
	ScannerName *string                   `json:"scannerName,omitempty"`
	Severity    *MisconfigurationSeverity `json:"severity,omitempty"`
}

// MisconfigurationFindingInfo defines model for MisconfigurationFindingInfo.
type MisconfigurationFindingInfo struct {
	// Category Specifies misconfiguration impact category
	Category *string `json:"category,omitempty"`

	// Description Additional context such as the potential impact
	Description *string `json:"description,omitempty"`

	// Id Check or test ID, if applicable (e.g. Lynis TestID, CIS Docker Benchmark checkpoint code, etc)
	Id *string `json:"id,omitempty"`

	// Location Location within the asset where the misconfiguration was recorded (e.g. filesystem path)
	Location *string `json:"location,omitempty"`

	// Message Short info about the misconfiguration
	Message    *string `json:"message,omitempty"`
	ObjectType string  `json:"objectType"`

	// Remediation Possible fix for the misconfiguration
	Remediation *string                   `json:"remediation,omitempty"`
	ScannerName *string                   `json:"scannerName,omitempty"`
	Severity    *MisconfigurationSeverity `json:"severity,omitempty"`
}

// MisconfigurationScan defines model for MisconfigurationScan.
type MisconfigurationScan struct {
	Misconfigurations *[]Misconfiguration `json:"misconfigurations"`
	Scanners          *[]string           `json:"scanners"`
	Status            *ScannerStatus      `json:"status,omitempty"`
}

// MisconfigurationSeverity defines model for MisconfigurationSeverity.
type MisconfigurationSeverity string

// MisconfigurationsConfig defines model for MisconfigurationsConfig.
type MisconfigurationsConfig struct {
	Enabled  *bool     `json:"enabled,omitempty"`
	Scanners *[]string `json:"scanners,omitempty"`
}

// Package defines model for Package.
type Package struct {
	Cpes     *[]string `json:"cpes"`
	Language *string   `json:"language,omitempty"`
	Licenses *[]string `json:"licenses"`
	Name     *string   `json:"name,omitempty"`
	Purl     *string   `json:"purl,omitempty"`
	Type     *string   `json:"type,omitempty"`
	Version  *string   `json:"version,omitempty"`
}

// PackageFindingInfo defines model for PackageFindingInfo.
type PackageFindingInfo struct {
	Cpes       *[]string `json:"cpes"`
	Language   *string   `json:"language,omitempty"`
	Licenses   *[]string `json:"licenses"`
	Name       *string   `json:"name,omitempty"`
	ObjectType string    `json:"objectType"`
	Purl       *string   `json:"purl,omitempty"`
	Type       *string   `json:"type,omitempty"`
	Version    *string   `json:"version,omitempty"`
}

// PluginScan defines model for PluginScan.
type PluginScan struct {
	FindingInfos *[]FindingInfo `json:"findingInfos"`
	Status       *ScannerStatus `json:"status,omitempty"`
}

// PluginScannerConfig defines model for PluginScannerConfig.
type PluginScannerConfig struct {
	Config    *string `json:"config,omitempty"`
	ImageName *string `json:"image_name,omitempty"`
}

// PluginsConfig defines model for PluginsConfig.
type PluginsConfig struct {
	Enabled        *bool                           `json:"enabled,omitempty"`
	ScannersConfig *map[string]PluginScannerConfig `json:"scanners_config,omitempty"`
	ScannersList   *[]string                       `json:"scanners_list,omitempty"`
}

// PodInfo defines model for PodInfo.
type PodInfo struct {
	Location   *string `json:"location,omitempty"`
	ObjectType string  `json:"objectType"`
	PodName    *string `json:"podName,omitempty"`
}

// Provider defines model for Provider.
type Provider struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// DisplayName Human-readable name for the provider.
	DisplayName *string `json:"displayName,omitempty"`
	Id          *string `json:"id,omitempty"`

	// LastHeartbeatTime Timestamp of the last heartbeat from the provider.
	LastHeartbeatTime *time.Time `json:"lastHeartbeatTime,omitempty"`

	// ProviderRuntimeVersion Version of the provider runtime that the provider was compiled with.
	ProviderRuntimeVersion *string         `json:"providerRuntimeVersion,omitempty"`
	Revision               *int            `json:"revision,omitempty"`
	Status                 *ProviderStatus `json:"status,omitempty"`
}

// ProviderExists defines model for ProviderExists.
type ProviderExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`

	// Provider Describes a provider object.
	Provider *Provider `json:"provider,omitempty"`
}

// ProviderRelationship defines model for ProviderRelationship.
type ProviderRelationship struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// DisplayName Human-readable name for the provider.
	DisplayName *string `json:"displayName,omitempty"`
	Id          *string `json:"id,omitempty"`

	// LastHeartbeatTime Timestamp of the last heartbeat from the provider.
	LastHeartbeatTime *time.Time `json:"lastHeartbeatTime,omitempty"`

	// ProviderRuntimeVersion Version of the provider runtime that the provider was compiled with.
	ProviderRuntimeVersion *string         `json:"providerRuntimeVersion,omitempty"`
	Revision               *int            `json:"revision,omitempty"`
	Status                 *ProviderStatus `json:"status,omitempty"`
}

// ProviderStatus defines model for ProviderStatus.
type ProviderStatus struct {
	// LastTransitionTime Last date-time when the status has changed.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message Human-readable message indicating details about the last state transition.
	Message *string `json:"message,omitempty"`

	// Reason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
	Reason ProviderStatusReason `json:"reason"`

	// State Describes the health state of the provider.
	//
	// | State     | Description                                    |
	// | --------- | ---------------------------------------------- |
	// | Healthy   | Provider is healthy.                           |
	// | Unhealthy | Heartbeat received, but Provider is unhealthy. |
	// | Unknown   | No heartbeat received from Provider.           |
	State ProviderStatusState `json:"state"`
}

// ProviderStatusReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
type ProviderStatusReason string

// ProviderStatusState Describes the health state of the provider.
//
// | State     | Description                                    |
// | --------- | ---------------------------------------------- |
// | Healthy   | Provider is healthy.                           |
// | Unhealthy | Heartbeat received, but Provider is unhealthy. |
// | Unknown   | No heartbeat received from Provider.           |
type ProviderStatusState string

// Providers defines model for Providers.
type Providers struct {
	// Count Total providers count according the given filters
	Count *int `json:"count,omitempty"`

	// Items List of providers in the given filters and page. List length must be lower or equal to pageSize.
	Items *[]Provider `json:"items,omitempty"`
}

// ResourceCleanupStatus defines model for ResourceCleanupStatus.
type ResourceCleanupStatus struct {
	// LastTransitionTime Last date time when the status has changed.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message Human readable message.
	Message *string `json:"message,omitempty"`

	// Reason Machine readable reason for state transition.
	//
	// | State   | Reason          | Description                                                            |
	// | ------- | --------------- | ---------------------------------------------------------------------- |
	// | Pending | AssetScanCreate | AssetScan created                                                      |
	// | Skipped | NotApplicable   | Resource cleanup is not required as it is managed outside of VMClarity |
	// | Skipped | DeletePolicy    | Resource cleanup has been skipped due to Delete Job Policy             |
	// | Failed  | ProviderError   | Failed due to Provider error                                           |
	// | Failed  | InternalError   | Failed due to internal error                                           |
	// | Done    | Success         | Successfully completed                                                 |
	Reason ResourceCleanupStatusReason `json:"reason"`

	// State Describes the state of resource cleanup.
	//
	// | State   | Description                                                |
	// | ------- | ---------------------------------------------------------- |
	// | Pending | Initial state for cleaning up resources                    |
	// | Skipped | Resource cleanup has been skipped due to Delete Job Policy |
	// | Failed  | Cleaning up resources has been failed                      |
	// | Done    | Resources have been successfully cleaned up                |
	State ResourceCleanupStatusState `json:"state"`
}

// ResourceCleanupStatusReason Machine readable reason for state transition.
//
// | State   | Reason          | Description                                                            |
// | ------- | --------------- | ---------------------------------------------------------------------- |
// | Pending | AssetScanCreate | AssetScan created                                                      |
// | Skipped | NotApplicable   | Resource cleanup is not required as it is managed outside of VMClarity |
// | Skipped | DeletePolicy    | Resource cleanup has been skipped due to Delete Job Policy             |
// | Failed  | ProviderError   | Failed due to Provider error                                           |
// | Failed  | InternalError   | Failed due to internal error                                           |
// | Done    | Success         | Successfully completed                                                 |
type ResourceCleanupStatusReason string

// ResourceCleanupStatusState Describes the state of resource cleanup.
//
// | State   | Description                                                |
// | ------- | ---------------------------------------------------------- |
// | Pending | Initial state for cleaning up resources                    |
// | Skipped | Resource cleanup has been skipped due to Delete Job Policy |
// | Failed  | Cleaning up resources has been failed                      |
// | Done    | Resources have been successfully cleaned up                |
type ResourceCleanupStatusState string

// RootVolume Information about VM root volume
type RootVolume struct {
	Encrypted RootVolumeEncrypted `json:"encrypted"`
	SizeGB    int                 `json:"sizeGB"`
}

// RootVolumeEncrypted defines model for RootVolume.Encrypted.
type RootVolumeEncrypted string

// Rootkit defines model for Rootkit.
type Rootkit struct {
	Message     *string      `json:"message,omitempty"`
	RootkitName *string      `json:"rootkitName,omitempty"`
	RootkitType *RootkitType `json:"rootkitType,omitempty"`
}

// RootkitFindingInfo defines model for RootkitFindingInfo.
type RootkitFindingInfo struct {
	Message     *string      `json:"message,omitempty"`
	ObjectType  string       `json:"objectType"`
	RootkitName *string      `json:"rootkitName,omitempty"`
	RootkitType *RootkitType `json:"rootkitType,omitempty"`
}

// RootkitScan defines model for RootkitScan.
type RootkitScan struct {
	Rootkits *[]Rootkit     `json:"rootkits"`
	Status   *ScannerStatus `json:"status,omitempty"`
}

// RootkitType defines model for RootkitType.
type RootkitType string

// RootkitsConfig defines model for RootkitsConfig.
type RootkitsConfig struct {
	Enabled  *bool     `json:"enabled,omitempty"`
	Scanners *[]string `json:"scanners,omitempty"`
}

// RuntimeScheduleScanConfig Runtime schedule scan configuration. If only operationTime is set, it will be a single scan scheduled for the operationTime. If only cronLine is set, the current time will be the "from time" to start the scheduling according to the cronLine. If both operationTime and cronLine are set, the first scan will run at operationTime and the operationTime will be the first time that the cronLine will be effective from.
type RuntimeScheduleScanConfig struct {
	// CronLine Cron schedule expressions.
	CronLine *string `json:"cronLine,omitempty"`

	// OperationTime The next time this ScanConfig should trigger a scan.
	OperationTime *time.Time `json:"operationTime,omitempty"`
}

// SBOMConfig defines model for SBOMConfig.
type SBOMConfig struct {
	Analyzers *[]string `json:"analyzers,omitempty"`
	Enabled   *bool     `json:"enabled,omitempty"`
}

// SbomScan defines model for SbomScan.
type SbomScan struct {
	Packages *[]Package     `json:"packages"`
	Status   *ScannerStatus `json:"status,omitempty"`
}

// Scan defines model for Scan.
type Scan struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// AssetIDs List of asset IDs to be scanned
	AssetIDs          *[]string          `json:"assetIDs"`
	AssetScanTemplate *AssetScanTemplate `json:"assetScanTemplate,omitempty"`
	EndTime           *time.Time         `json:"endTime,omitempty"`
	Id                *string            `json:"id,omitempty"`

	// MaxParallelScanners The maximum number of asset scans that can be scheduled in parallel for this scan
	MaxParallelScanners *int    `json:"maxParallelScanners,omitempty"`
	Name                *string `json:"name,omitempty"`
	Revision            *int    `json:"revision,omitempty"`

	// ScanConfig Describes a relationship to a scan config which can be expanded.
	ScanConfig *ScanConfigRelationship `json:"scanConfig,omitempty"`

	// Scope The query used to limit the scope of this scan. It uses
	// the ODATA $filter query language to limit the collection of assets
	// that this scan will operate over. For example
	// `startswith(assetInfo.location, 'eu-west-2')` will limit this scan
	// to just assets in the eu-west-2 AWS region.
	Scope     *string     `json:"scope,omitempty"`
	StartTime *time.Time  `json:"startTime,omitempty"`
	Status    *ScanStatus `json:"status,omitempty"`

	// Summary A summary of the progress of a scan for informational purposes.
	Summary *ScanSummary `json:"summary,omitempty"`

	// TimeoutSeconds The maximum time in seconds that a scan started from this config
	// should run for before being automatically aborted.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// ScanConfig defines model for ScanConfig.
type ScanConfig struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Disabled if true, the scan config is disabled and no scan should run from it
	Disabled     *bool         `json:"disabled,omitempty"`
	Id           *string       `json:"id,omitempty"`
	Name         *string       `json:"name,omitempty"`
	Revision     *int          `json:"revision,omitempty"`
	ScanTemplate *ScanTemplate `json:"scanTemplate,omitempty"`

	// Scheduled Runtime schedule scan configuration. If only operationTime is set, it will be a single scan scheduled for the operationTime. If only cronLine is set, the current time will be the "from time" to start the scheduling according to the cronLine. If both operationTime and cronLine are set, the first scan will run at operationTime and the operationTime will be the first time that the cronLine will be effective from.
	Scheduled *RuntimeScheduleScanConfig `json:"scheduled,omitempty"`
}

// ScanConfigExists defines model for ScanConfigExists.
type ScanConfigExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`

	// ScanConfig Describes a multi-asset scheduled scan config.
	ScanConfig *ScanConfig `json:"scanConfig,omitempty"`
}

// ScanConfigRelationship defines model for ScanConfigRelationship.
type ScanConfigRelationship struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Disabled if true, the scan config is disabled and no scan should run from it
	Disabled     *bool         `json:"disabled,omitempty"`
	Id           string        `json:"id"`
	Name         *string       `json:"name,omitempty"`
	Revision     *int          `json:"revision,omitempty"`
	ScanTemplate *ScanTemplate `json:"scanTemplate,omitempty"`

	// Scheduled Runtime schedule scan configuration. If only operationTime is set, it will be a single scan scheduled for the operationTime. If only cronLine is set, the current time will be the "from time" to start the scheduling according to the cronLine. If both operationTime and cronLine are set, the first scan will run at operationTime and the operationTime will be the first time that the cronLine will be effective from.
	Scheduled *RuntimeScheduleScanConfig `json:"scheduled,omitempty"`
}

// ScanConfigs defines model for ScanConfigs.
type ScanConfigs struct {
	// Count Total scan config count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of scan configs according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]ScanConfig `json:"items,omitempty"`
}

// ScanEstimation defines model for ScanEstimation.
type ScanEstimation struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// AssetIDs List of asset IDs to be estimated
	AssetIDs *[]string `json:"assetIDs,omitempty"`

	// AssetScanEstimations AssetScanEstimations which make up this ScanEstimation
	AssetScanEstimations *[]AssetScanEstimationRelationship `json:"assetScanEstimations,omitempty"`

	// DeleteAfter The time this resource should be deleted. This value is calculated by endTime + ttlSecondsAfterFinished. This should not be set by the user, but use ttlSecondsAfterFinished instead.
	DeleteAfter  *time.Time            `json:"deleteAfter,omitempty"`
	EndTime      *time.Time            `json:"endTime,omitempty"`
	Id           *string               `json:"id,omitempty"`
	Revision     *int                  `json:"revision,omitempty"`
	ScanTemplate *ScanTemplate         `json:"scanTemplate,omitempty"`
	StartTime    *time.Time            `json:"startTime,omitempty"`
	Status       *ScanEstimationStatus `json:"status,omitempty"`

	// Summary A summary of the AssetScanEstimations under this ScanEstimation
	Summary *ScanEstimationSummary `json:"summary,omitempty"`

	// TTLSecondsAfterFinished The duration in seconds this resource should last until it is deleted.
	TTLSecondsAfterFinished *int `json:"ttlSecondsAfterFinished,omitempty"`
}

// ScanEstimationRelationship defines model for ScanEstimationRelationship.
type ScanEstimationRelationship struct {
	Id *string `json:"id,omitempty"`
}

// ScanEstimationStatus defines model for ScanEstimationStatus.
type ScanEstimationStatus struct {
	// LastTransitionTime Last date time when the status has changed.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message Human readable message.
	Message *string `json:"message,omitempty"`

	// Reason Machine readable reason for state transition.
	//
	// | State      | Reason              | Description                                                       |
	// | ---------- | ------------------- | ----------------------------------------------------------------- |
	// | Pending    | Created             | Initial state for ScanEstimation                                  |
	// | Discovered | SuccessfulDiscovery | Assets to estimate successfully discovered                        |
	// | InProgress | Running             | Scan estimation is currently in progress                          |
	// | Aborted    | Cancellation        | ScanEstimation has been cancelled                                 |
	// | Failed     | Aborted             | ScanEstimation has failed due to abort                            |
	// | Failed     | Error               | ScanEstimation has failed due to an error                         |
	// | Failed     | Timeout             | ScanEstimation has failed due to timeout                          |
	// | Done       | NothingToEstimate   | ScanEstimation has finished because there was nothing to estimate |
	// | Done       | Success             | ScanEstimation has finished successfully                          |
	Reason ScanEstimationStatusReason `json:"reason"`

	// State Describes the state of scan estimation.
	//
	// | State      | Description                              |
	// | ---------- | ---------------------------------------- |
	// | Pending    | Initial state for ScanEstimation         |
	// | Discovered | Assets have been discovered              |
	// | InProgress | Scan estimation is in progress           |
	// | Aborted    | ScanEstimation has aborted               |
	// | Failed     | ScanEstimation has failed                |
	// | Done       | ScanEstimation has finished successfully |
	State ScanEstimationStatusState `json:"state"`
}

// ScanEstimationStatusReason Machine readable reason for state transition.
//
// | State      | Reason              | Description                                                       |
// | ---------- | ------------------- | ----------------------------------------------------------------- |
// | Pending    | Created             | Initial state for ScanEstimation                                  |
// | Discovered | SuccessfulDiscovery | Assets to estimate successfully discovered                        |
// | InProgress | Running             | Scan estimation is currently in progress                          |
// | Aborted    | Cancellation        | ScanEstimation has been cancelled                                 |
// | Failed     | Aborted             | ScanEstimation has failed due to abort                            |
// | Failed     | Error               | ScanEstimation has failed due to an error                         |
// | Failed     | Timeout             | ScanEstimation has failed due to timeout                          |
// | Done       | NothingToEstimate   | ScanEstimation has finished because there was nothing to estimate |
// | Done       | Success             | ScanEstimation has finished successfully                          |
type ScanEstimationStatusReason string

// ScanEstimationStatusState Describes the state of scan estimation.
//
// | State      | Description                              |
// | ---------- | ---------------------------------------- |
// | Pending    | Initial state for ScanEstimation         |
// | Discovered | Assets have been discovered              |
// | InProgress | Scan estimation is in progress           |
// | Aborted    | ScanEstimation has aborted               |
// | Failed     | ScanEstimation has failed                |
// | Done       | ScanEstimation has finished successfully |
type ScanEstimationStatusState string

// ScanEstimationSummary A summary of the AssetScanEstimations under this ScanEstimation
type ScanEstimationSummary struct {
	JobsCompleted *int `json:"jobsCompleted,omitempty"`
	JobsLeftToRun *int `json:"jobsLeftToRun,omitempty"`

	// TotalScanCost Total estimated cost of the scan ($)
	TotalScanCost *float32 `json:"totalScanCost,omitempty"`

	// TotalScanSize Total estimated size of the scan (GB)
	TotalScanSize *int `json:"totalScanSize,omitempty"`

	// TotalScanTime Total estimated time the scan will take (seconds)
	TotalScanTime *int `json:"totalScanTime,omitempty"`
}

// ScanEstimations defines model for ScanEstimations.
type ScanEstimations struct {
	// Count Total ScanEstimations count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of ScanEstimations according to the given filters
	Items *[]ScanEstimation `json:"items,omitempty"`
}

// ScanExists defines model for ScanExists.
type ScanExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`

	// Scan Describes a multi-asset scheduled scan.
	Scan *Scan `json:"scan,omitempty"`
}

// ScanFamiliesConfig The configuration of the scanner families within a scan config
type ScanFamiliesConfig struct {
	Exploits          *ExploitsConfig          `json:"exploits,omitempty"`
	InfoFinder        *InfoFinderConfig        `json:"infoFinder,omitempty"`
	Malware           *MalwareConfig           `json:"malware,omitempty"`
	Misconfigurations *MisconfigurationsConfig `json:"misconfigurations,omitempty"`
	Plugins           *PluginsConfig           `json:"plugins,omitempty"`
	Rootkits          *RootkitsConfig          `json:"rootkits,omitempty"`
	Sbom              *SBOMConfig              `json:"sbom,omitempty"`
	Secrets           *SecretsConfig           `json:"secrets,omitempty"`
	Vulnerabilities   *VulnerabilitiesConfig   `json:"vulnerabilities,omitempty"`
}

// ScanFindingsSummary A summary of the scan findings.
type ScanFindingsSummary struct {
	TotalExploits          *int `json:"totalExploits,omitempty"`
	TotalInfoFinder        *int `json:"totalInfoFinder,omitempty"`
	TotalMalware           *int `json:"totalMalware,omitempty"`
	TotalMisconfigurations *int `json:"totalMisconfigurations,omitempty"`
	TotalPackages          *int `json:"totalPackages,omitempty"`
	TotalPlugins           *int `json:"totalPlugins,omitempty"`
	TotalRootkits          *int `json:"totalRootkits,omitempty"`
	TotalSecrets           *int `json:"totalSecrets,omitempty"`

	// TotalVulnerabilities A summary of number of vulnerabilities found per severity.
	TotalVulnerabilities *VulnerabilitySeveritySummary `json:"totalVulnerabilities,omitempty"`
}

// ScanRelationship defines model for ScanRelationship.
type ScanRelationship struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// AssetIDs List of asset IDs to be scanned
	AssetIDs          *[]string          `json:"assetIDs"`
	AssetScanTemplate *AssetScanTemplate `json:"assetScanTemplate,omitempty"`
	EndTime           *time.Time         `json:"endTime,omitempty"`
	Id                string             `json:"id"`

	// MaxParallelScanners The maximum number of asset scans that can be scheduled in parallel for this scan
	MaxParallelScanners *int    `json:"maxParallelScanners,omitempty"`
	Name                *string `json:"name,omitempty"`
	Revision            *int    `json:"revision,omitempty"`

	// ScanConfig Describes a relationship to a scan config which can be expanded.
	ScanConfig *ScanConfigRelationship `json:"scanConfig,omitempty"`

	// Scope The query used to limit the scope of this scan. It uses
	// the ODATA $filter query language to limit the collection of assets
	// that this scan will operate over. For example
	// `startswith(assetInfo.location, 'eu-west-2')` will limit this scan
	// to just assets in the eu-west-2 AWS region.
	Scope     *string     `json:"scope,omitempty"`
	StartTime *time.Time  `json:"startTime,omitempty"`
	Status    *ScanStatus `json:"status,omitempty"`

	// Summary A summary of the progress of a scan for informational purposes.
	Summary *ScanSummary `json:"summary,omitempty"`

	// TimeoutSeconds The maximum time in seconds that a scan started from this config
	// should run for before being automatically aborted.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// ScanStatus defines model for ScanStatus.
type ScanStatus struct {
	// LastTransitionTime Last date time when the status has changed.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message Human readable message.
	Message *string `json:"message,omitempty"`

	// Reason Machine readable reason for state transition.
	//
	// | State      | Reason            | Description                                                |
	// | ---------- | ----------------- | ---------------------------------------------------------- |
	// | Pending    | Created           | Scan is pending as it has been newly created               |
	// | Discovered | AssetsDiscovered  | Assets that fall into the scope of the Scan are discovered |
	// | InProgress | AssetScansRunning | AssetScans are currently running                           |
	// | Aborted    | Cancellation      | AssetScans are being moved to Aborted state                |
	// | Failed     | Cancellation      | AssetScans are in Aborted state                            |
	// | Failed     | Error             | At least one AssetScan has ended with an error             |
	// | Failed     | Timeout           | Scan has been timed out                                    |
	// | Done       | NothingToScan     | There are no assets that need to be scanned                |
	// | Done       | Success           | Scan ended successfully without any errors                 |
	Reason ScanStatusReason `json:"reason"`

	// State Describes the state of Scan.
	//
	// | State      | Description                                                                   |
	// | ---------- | ----------------------------------------------------------------------------- |
	// | Pending    | The initial state when the scan is created, and is working to discover assets |
	// | Discovered | The asset scans have been discovered and are waiting to be scheduled          |
	// | InProgress | The asset scans have been scheduled and the assets are being scanned          |
	// | Aborted    | The scan has been aborted                                                     |
	// | Failed     | One or more assets could not be successfully scanned                          |
	// | Done       | All assets have been scanned successfully                                     |
	State ScanStatusState `json:"state"`
}

// ScanStatusReason Machine readable reason for state transition.
//
// | State      | Reason            | Description                                                |
// | ---------- | ----------------- | ---------------------------------------------------------- |
// | Pending    | Created           | Scan is pending as it has been newly created               |
// | Discovered | AssetsDiscovered  | Assets that fall into the scope of the Scan are discovered |
// | InProgress | AssetScansRunning | AssetScans are currently running                           |
// | Aborted    | Cancellation      | AssetScans are being moved to Aborted state                |
// | Failed     | Cancellation      | AssetScans are in Aborted state                            |
// | Failed     | Error             | At least one AssetScan has ended with an error             |
// | Failed     | Timeout           | Scan has been timed out                                    |
// | Done       | NothingToScan     | There are no assets that need to be scanned                |
// | Done       | Success           | Scan ended successfully without any errors                 |
type ScanStatusReason string

// ScanStatusState Describes the state of Scan.
//
// | State      | Description                                                                   |
// | ---------- | ----------------------------------------------------------------------------- |
// | Pending    | The initial state when the scan is created, and is working to discover assets |
// | Discovered | The asset scans have been discovered and are waiting to be scheduled          |
// | InProgress | The asset scans have been scheduled and the assets are being scanned          |
// | Aborted    | The scan has been aborted                                                     |
// | Failed     | One or more assets could not be successfully scanned                          |
// | Done       | All assets have been scanned successfully                                     |
type ScanStatusState string

// ScanSummary defines model for ScanSummary.
type ScanSummary struct {
	JobsCompleted          *int `json:"jobsCompleted,omitempty"`
	JobsLeftToRun          *int `json:"jobsLeftToRun,omitempty"`
	TotalExploits          *int `json:"totalExploits,omitempty"`
	TotalInfoFinder        *int `json:"totalInfoFinder,omitempty"`
	TotalMalware           *int `json:"totalMalware,omitempty"`
	TotalMisconfigurations *int `json:"totalMisconfigurations,omitempty"`
	TotalPackages          *int `json:"totalPackages,omitempty"`
	TotalPlugins           *int `json:"totalPlugins,omitempty"`
	TotalRootkits          *int `json:"totalRootkits,omitempty"`
	TotalSecrets           *int `json:"totalSecrets,omitempty"`

	// TotalVulnerabilities A summary of number of vulnerabilities found per severity.
	TotalVulnerabilities *VulnerabilitySeveritySummary `json:"totalVulnerabilities,omitempty"`
}

// ScanTemplate defines model for ScanTemplate.
type ScanTemplate struct {
	AssetScanTemplate *AssetScanTemplate `json:"assetScanTemplate,omitempty"`

	// MaxParallelScanners The maximum number of asset scans that can be scheduled in parallel for this scan
	MaxParallelScanners *int `json:"maxParallelScanners,omitempty"`

	// Scope The query used to limit the scope of this scan. It uses
	// the ODATA $filter query language to limit the collection of assets
	// that this scan will operate over. For example
	// `startswith(assetInfo.location, 'eu-west-2')` will limit this scan
	// to just assets in the eu-west-2 AWS region.
	Scope *string `json:"scope,omitempty"`

	// TimeoutSeconds The maximum time in seconds that a scan started from this config
	// should run for before being automatically aborted.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// ScanTemplateReadOnly defines model for ScanTemplateReadOnly.
type ScanTemplateReadOnly struct {
	AssetScanTemplate *AssetScanTemplate `json:"assetScanTemplate,omitempty"`

	// MaxParallelScanners The maximum number of asset scans that can be scheduled in parallel for this scan
	MaxParallelScanners *int `json:"maxParallelScanners,omitempty"`

	// Scope The query used to limit the scope of this scan. It uses
	// the ODATA $filter query language to limit the collection of assets
	// that this scan will operate over. For example
	// `startswith(assetInfo.location, 'eu-west-2')` will limit this scan
	// to just assets in the eu-west-2 AWS region.
	Scope *string `json:"scope,omitempty"`

	// TimeoutSeconds The maximum time in seconds that a scan started from this config
	// should run for before being automatically aborted.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// ScanType defines model for ScanType.
type ScanType string

// ScannerInstanceCreationConfig Configuration of scanner instance
type ScannerInstanceCreationConfig struct {
	MaxPrice         *string `json:"maxPrice,omitempty"`
	RetryMaxAttempts *int    `json:"retryMaxAttempts,omitempty"`
	UseSpotInstances bool    `json:"useSpotInstances"`
}

// ScannerMetadata defines model for ScannerMetadata.
type ScannerMetadata struct {
	ScannerName    *string         `json:"scannerName,omitempty"`
	ScannerSummary *ScannerSummary `json:"scannerSummary,omitempty"`
}

// ScannerStatus defines model for ScannerStatus.
type ScannerStatus struct {
	// LastTransitionTime Last date time when the status has changed.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message Human readable message.
	Message *string `json:"message,omitempty"`

	// Reason Machine readable reason for state transition.
	//
	// | State      | Reason            | Description                                 |
	// | ---------- | ----------------- | ------------------------------------------- |
	// | Pending    | Scheduled         | Scanner has been enabled in ScanConfig      |
	// | InProgress | Scanning          | Scanner is currently running                |
	// | Skipped    | NotScheduled      | Scanner hasn't been enabled in ScanConfig   |
	// | Failed     | Error             | Scanner finished with an error              |
	// | Done       | Success           | Scanner finished successfully               |
	Reason ScannerStatusReason `json:"reason"`

	// State Describes the state of a scanner on the asset.
	//
	// | State       | Description                                                              |
	// | ----------- | ------------------------------------------------------------------------ |
	// | Pending     | Scanner is pending and waits for state transition to InProgress state    |
	// | InProgress  | Scanning is being performed                                              |
	// | Skipped     | Scanner is **not** scheduled                                             |
	// | Failed      | Scanner has failed, check *reason* and *message* fields for the details  |
	// | Done        | Scanner has finished scanning with no errors                             |
	State ScannerStatusState `json:"state"`
}

// ScannerStatusReason Machine readable reason for state transition.
//
// | State      | Reason            | Description                                 |
// | ---------- | ----------------- | ------------------------------------------- |
// | Pending    | Scheduled         | Scanner has been enabled in ScanConfig      |
// | InProgress | Scanning          | Scanner is currently running                |
// | Skipped    | NotScheduled      | Scanner hasn't been enabled in ScanConfig   |
// | Failed     | Error             | Scanner finished with an error              |
// | Done       | Success           | Scanner finished successfully               |
type ScannerStatusReason string

// ScannerStatusState Describes the state of a scanner on the asset.
//
// | State       | Description                                                              |
// | ----------- | ------------------------------------------------------------------------ |
// | Pending     | Scanner is pending and waits for state transition to InProgress state    |
// | InProgress  | Scanning is being performed                                              |
// | Skipped     | Scanner is **not** scheduled                                             |
// | Failed      | Scanner has failed, check *reason* and *message* fields for the details  |
// | Done        | Scanner has finished scanning with no errors                             |
type ScannerStatusState string

// ScannerSummary defines model for ScannerSummary.
type ScannerSummary struct {
	DataRead           *string `json:"DataRead,omitempty"`
	DataScanned        *string `json:"DataScanned,omitempty"`
	EngineVersion      *string `json:"EngineVersion,omitempty"`
	InfectedFiles      *int    `json:"InfectedFiles,omitempty"`
	KnownViruses       *int    `json:"KnownViruses,omitempty"`
	ScannedDirectories *int    `json:"ScannedDirectories,omitempty"`
	ScannedFiles       *int    `json:"ScannedFiles,omitempty"`
	SuspectedFiles     *int    `json:"SuspectedFiles,omitempty"`
	TimeTaken          *string `json:"TimeTaken,omitempty"`
}

// Scans defines model for Scans.
type Scans struct {
	// Count Total scans count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of scans according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]Scan `json:"items,omitempty"`
}

// Secret defines model for Secret.
type Secret struct {
	Description *string `json:"description,omitempty"`
	EndColumn   *int    `json:"endColumn,omitempty"`
	EndLine     *int    `json:"endLine,omitempty"`

	// FilePath Name of the file containing the secret
	FilePath *string `json:"filePath,omitempty"`

	// Fingerprint Note: this is not unique
	Fingerprint *string `json:"fingerprint,omitempty"`
	StartColumn *int    `json:"startColumn,omitempty"`
	StartLine   *int    `json:"startLine,omitempty"`
}

// SecretFindingInfo defines model for SecretFindingInfo.
type SecretFindingInfo struct {
	Description *string `json:"description,omitempty"`
	EndColumn   *int    `json:"endColumn,omitempty"`
	EndLine     *int    `json:"endLine,omitempty"`

	// FilePath Name of the file containing the secret
	FilePath *string `json:"filePath,omitempty"`

	// Fingerprint Note: this is not unique
	Fingerprint *string `json:"fingerprint,omitempty"`
	ObjectType  string  `json:"objectType"`
	StartColumn *int    `json:"startColumn,omitempty"`
	StartLine   *int    `json:"startLine,omitempty"`
}

// SecretScan defines model for SecretScan.
type SecretScan struct {
	Secrets *[]Secret      `json:"secrets"`
	Status  *ScannerStatus `json:"status,omitempty"`
}

// SecretsConfig defines model for SecretsConfig.
type SecretsConfig struct {
	Enabled  *bool     `json:"enabled,omitempty"`
	Scanners *[]string `json:"scanners,omitempty"`
}

// SecurityGroup general cloud security group
type SecurityGroup struct {
	Id string `json:"id"`
}

// SuccessResponse An object that is returned in cases of success that returns nothing.
type SuccessResponse struct {
	Message *string `json:"message,omitempty"`
}

// Tag general cloud tag / label
type Tag struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// VMInfo defines model for VMInfo.
type VMInfo struct {
	Image            string         `json:"image"`
	InstanceID       string         `json:"instanceID"`
	InstanceProvider *CloudProvider `json:"instanceProvider,omitempty"`
	InstanceType     string         `json:"instanceType"`
	LaunchTime       time.Time      `json:"launchTime"`
	Location         string         `json:"location"`
	ObjectType       string         `json:"objectType"`
	Platform         string         `json:"platform"`

	// RootVolume Information about VM root volume
	RootVolume     RootVolume       `json:"rootVolume"`
	SecurityGroups *[]SecurityGroup `json:"securityGroups"`
	Tags           *[]Tag           `json:"tags"`
}

// VulnerabilitiesConfig defines model for VulnerabilitiesConfig.
type VulnerabilitiesConfig struct {
	Enabled  *bool     `json:"enabled,omitempty"`
	Scanners *[]string `json:"scanners,omitempty"`
}

// Vulnerability defines model for Vulnerability.
type Vulnerability struct {
	Cvss        *[]VulnerabilityCvss `json:"cvss"`
	Description *string              `json:"description,omitempty"`

	// Distro Distro provides information about a detected Linux distribution.
	Distro            *VulnerabilityDistro   `json:"distro,omitempty"`
	Fix               *VulnerabilityFix      `json:"fix,omitempty"`
	LayerId           *string                `json:"layerId,omitempty"`
	Links             *[]string              `json:"links"`
	Package           *Package               `json:"package,omitempty"`
	Path              *string                `json:"path,omitempty"`
	Severity          *VulnerabilitySeverity `json:"severity,omitempty"`
	VulnerabilityName *string                `json:"vulnerabilityName,omitempty"`
}

// VulnerabilityCvss defines model for VulnerabilityCvss.
type VulnerabilityCvss struct {
	Metrics *VulnerabilityCvssMetrics `json:"metrics,omitempty"`
	Vector  *string                   `json:"vector,omitempty"`
	Version *string                   `json:"version,omitempty"`
}

// VulnerabilityCvssMetrics defines model for VulnerabilityCvssMetrics.
type VulnerabilityCvssMetrics struct {
	BaseScore           *float32 `json:"baseScore,omitempty"`
	ExploitabilityScore *float32 `json:"exploitabilityScore,omitempty"`
	ImpactScore         *float32 `json:"impactScore,omitempty"`
}

// VulnerabilityDistro Distro provides information about a detected Linux distribution.
type VulnerabilityDistro struct {
	// IDLike the ID_LIKE field found within the /etc/os-release file
	IDLike *[]string `json:"IDLike"`

	// Name Name of the Linux distribution
	Name *string `json:"name,omitempty"`

	// Version Version of the Linux distribution (major or major.minor version)
	Version *string `json:"version,omitempty"`
}

// VulnerabilityFindingInfo defines model for VulnerabilityFindingInfo.
type VulnerabilityFindingInfo struct {
	Cvss        *[]VulnerabilityCvss `json:"cvss"`
	Description *string              `json:"description,omitempty"`

	// Distro Distro provides information about a detected Linux distribution.
	Distro            *VulnerabilityDistro   `json:"distro,omitempty"`
	Fix               *VulnerabilityFix      `json:"fix,omitempty"`
	LayerId           *string                `json:"layerId,omitempty"`
	Links             *[]string              `json:"links"`
	ObjectType        string                 `json:"objectType"`
	Package           *Package               `json:"package,omitempty"`
	Path              *string                `json:"path,omitempty"`
	Severity          *VulnerabilitySeverity `json:"severity,omitempty"`
	VulnerabilityName *string                `json:"vulnerabilityName,omitempty"`
}

// VulnerabilityFix defines model for VulnerabilityFix.
type VulnerabilityFix struct {
	State    *string   `json:"state,omitempty"`
	Versions *[]string `json:"versions"`
}

// VulnerabilityScan defines model for VulnerabilityScan.
type VulnerabilityScan struct {
	Status          *ScannerStatus   `json:"status,omitempty"`
	Vulnerabilities *[]Vulnerability `json:"vulnerabilities"`
}

// VulnerabilitySeverity defines model for VulnerabilitySeverity.
type VulnerabilitySeverity string

// VulnerabilitySeveritySummary A summary of number of vulnerabilities found per severity.
type VulnerabilitySeveritySummary struct {
	TotalCriticalVulnerabilities   *int `json:"totalCriticalVulnerabilities,omitempty"`
	TotalHighVulnerabilities       *int `json:"totalHighVulnerabilities,omitempty"`
	TotalLowVulnerabilities        *int `json:"totalLowVulnerabilities,omitempty"`
	TotalMediumVulnerabilities     *int `json:"totalMediumVulnerabilities,omitempty"`
	TotalNegligibleVulnerabilities *int `json:"totalNegligibleVulnerabilities,omitempty"`
}

// AssetFindingID defines model for assetFindingID.
type AssetFindingID = string

// AssetID defines model for assetID.
type AssetID = string

// AssetScanEstimationID defines model for assetScanEstimationID.
type AssetScanEstimationID = string

// AssetScanID defines model for assetScanID.
type AssetScanID = string

// FindingID defines model for findingID.
type FindingID = string

// Ifmatch defines model for ifmatch.
type Ifmatch = int

// OdataCount defines model for odataCount.
type OdataCount = bool

// OdataExpand defines model for odataExpand.
type OdataExpand = string

// OdataFilter defines model for odataFilter.
type OdataFilter = string

// OrderBy defines model for odataOrderBy.
type OrderBy = string

// OdataSelect defines model for odataSelect.
type OdataSelect = string

// OdataSkip defines model for odataSkip.
type OdataSkip = int

// OdataTop defines model for odataTop.
type OdataTop = int

// ProviderID defines model for providerID.
type ProviderID = string

// ScanConfigID defines model for scanConfigID.
type ScanConfigID = string

// ScanEstimationID defines model for scanEstimationID.
type ScanEstimationID = string

// ScanID defines model for scanID.
type ScanID = string

// Success An object that is returned in cases of success that returns nothing.
type Success = SuccessResponse

// UnknownError An object that is returned in all cases of failures.
type UnknownError = ApiResponse

// GetAssetFindingsParams defines parameters for GetAssetFindings.
type GetAssetFindingsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetAssetFindingsAssetFindingIDParams defines parameters for GetAssetFindingsAssetFindingID.
type GetAssetFindingsAssetFindingIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchAssetFindingsAssetFindingIDParams defines parameters for PatchAssetFindingsAssetFindingID.
type PatchAssetFindingsAssetFindingIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutAssetFindingsAssetFindingIDParams defines parameters for PutAssetFindingsAssetFindingID.
type PutAssetFindingsAssetFindingIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetAssetScanEstimationsParams defines parameters for GetAssetScanEstimations.
type GetAssetScanEstimationsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetAssetScanEstimationsAssetScanEstimationIDParams defines parameters for GetAssetScanEstimationsAssetScanEstimationID.
type GetAssetScanEstimationsAssetScanEstimationIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchAssetScanEstimationsAssetScanEstimationIDParams defines parameters for PatchAssetScanEstimationsAssetScanEstimationID.
type PatchAssetScanEstimationsAssetScanEstimationIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutAssetScanEstimationsAssetScanEstimationIDParams defines parameters for PutAssetScanEstimationsAssetScanEstimationID.
type PutAssetScanEstimationsAssetScanEstimationIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetAssetScansParams defines parameters for GetAssetScans.
type GetAssetScansParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetAssetScansAssetScanIDParams defines parameters for GetAssetScansAssetScanID.
type GetAssetScansAssetScanIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchAssetScansAssetScanIDParams defines parameters for PatchAssetScansAssetScanID.
type PatchAssetScansAssetScanIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutAssetScansAssetScanIDParams defines parameters for PutAssetScansAssetScanID.
type PutAssetScansAssetScanIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetAssetsParams defines parameters for GetAssets.
type GetAssetsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetAssetsAssetIDParams defines parameters for GetAssetsAssetID.
type GetAssetsAssetIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchAssetsAssetIDParams defines parameters for PatchAssetsAssetID.
type PatchAssetsAssetIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutAssetsAssetIDParams defines parameters for PutAssetsAssetID.
type PutAssetsAssetIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetFindingsParams defines parameters for GetFindings.
type GetFindingsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetFindingsFindingIDParams defines parameters for GetFindingsFindingID.
type GetFindingsFindingIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// GetProvidersParams defines parameters for GetProviders.
type GetProvidersParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetProvidersProviderIDParams defines parameters for GetProvidersProviderID.
type GetProvidersProviderIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchProvidersProviderIDParams defines parameters for PatchProvidersProviderID.
type PatchProvidersProviderIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutProvidersProviderIDParams defines parameters for PutProvidersProviderID.
type PutProvidersProviderIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetScanConfigsParams defines parameters for GetScanConfigs.
type GetScanConfigsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetScanConfigsScanConfigIDParams defines parameters for GetScanConfigsScanConfigID.
type GetScanConfigsScanConfigIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchScanConfigsScanConfigIDParams defines parameters for PatchScanConfigsScanConfigID.
type PatchScanConfigsScanConfigIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutScanConfigsScanConfigIDParams defines parameters for PutScanConfigsScanConfigID.
type PutScanConfigsScanConfigIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetScanEstimationsParams defines parameters for GetScanEstimations.
type GetScanEstimationsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetScanEstimationsScanEstimationIDParams defines parameters for GetScanEstimationsScanEstimationID.
type GetScanEstimationsScanEstimationIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchScanEstimationsScanEstimationIDParams defines parameters for PatchScanEstimationsScanEstimationID.
type PatchScanEstimationsScanEstimationIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutScanEstimationsScanEstimationIDParams defines parameters for PutScanEstimationsScanEstimationID.
type PutScanEstimationsScanEstimationIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetScansParams defines parameters for GetScans.
type GetScansParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetScansScanIDParams defines parameters for GetScansScanID.
type GetScansScanIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchScansScanIDParams defines parameters for PatchScansScanID.
type PatchScansScanIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutScansScanIDParams defines parameters for PutScansScanID.
type PutScansScanIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PostAssetFindingsJSONRequestBody defines body for PostAssetFindings for application/json ContentType.
type PostAssetFindingsJSONRequestBody = AssetFinding

// PatchAssetFindingsAssetFindingIDJSONRequestBody defines body for PatchAssetFindingsAssetFindingID for application/json ContentType.
type PatchAssetFindingsAssetFindingIDJSONRequestBody = AssetFinding

// PutAssetFindingsAssetFindingIDJSONRequestBody defines body for PutAssetFindingsAssetFindingID for application/json ContentType.
type PutAssetFindingsAssetFindingIDJSONRequestBody = AssetFinding

// PostAssetScanEstimationsJSONRequestBody defines body for PostAssetScanEstimations for application/json ContentType.
type PostAssetScanEstimationsJSONRequestBody = AssetScanEstimation

// PatchAssetScanEstimationsAssetScanEstimationIDJSONRequestBody defines body for PatchAssetScanEstimationsAssetScanEstimationID for application/json ContentType.
type PatchAssetScanEstimationsAssetScanEstimationIDJSONRequestBody = AssetScanEstimation

// PutAssetScanEstimationsAssetScanEstimationIDJSONRequestBody defines body for PutAssetScanEstimationsAssetScanEstimationID for application/json ContentType.
type PutAssetScanEstimationsAssetScanEstimationIDJSONRequestBody = AssetScanEstimation

// PostAssetScansJSONRequestBody defines body for PostAssetScans for application/json ContentType.
type PostAssetScansJSONRequestBody = AssetScan

// PatchAssetScansAssetScanIDJSONRequestBody defines body for PatchAssetScansAssetScanID for application/json ContentType.
type PatchAssetScansAssetScanIDJSONRequestBody = AssetScan

// PutAssetScansAssetScanIDJSONRequestBody defines body for PutAssetScansAssetScanID for application/json ContentType.
type PutAssetScansAssetScanIDJSONRequestBody = AssetScan

// PostAssetsJSONRequestBody defines body for PostAssets for application/json ContentType.
type PostAssetsJSONRequestBody = Asset

// PatchAssetsAssetIDJSONRequestBody defines body for PatchAssetsAssetID for application/json ContentType.
type PatchAssetsAssetIDJSONRequestBody = Asset

// PutAssetsAssetIDJSONRequestBody defines body for PutAssetsAssetID for application/json ContentType.
type PutAssetsAssetIDJSONRequestBody = Asset

// PostFindingsJSONRequestBody defines body for PostFindings for application/json ContentType.
type PostFindingsJSONRequestBody = Finding

// PatchFindingsFindingIDJSONRequestBody defines body for PatchFindingsFindingID for application/json ContentType.
type PatchFindingsFindingIDJSONRequestBody = Finding

// PutFindingsFindingIDJSONRequestBody defines body for PutFindingsFindingID for application/json ContentType.
type PutFindingsFindingIDJSONRequestBody = Finding

// PostProvidersJSONRequestBody defines body for PostProviders for application/json ContentType.
type PostProvidersJSONRequestBody = Provider

// PatchProvidersProviderIDJSONRequestBody defines body for PatchProvidersProviderID for application/json ContentType.
type PatchProvidersProviderIDJSONRequestBody = Provider

// PutProvidersProviderIDJSONRequestBody defines body for PutProvidersProviderID for application/json ContentType.
type PutProvidersProviderIDJSONRequestBody = Provider

// PostScanConfigsJSONRequestBody defines body for PostScanConfigs for application/json ContentType.
type PostScanConfigsJSONRequestBody = ScanConfig

// PatchScanConfigsScanConfigIDJSONRequestBody defines body for PatchScanConfigsScanConfigID for application/json ContentType.
type PatchScanConfigsScanConfigIDJSONRequestBody = ScanConfig

// PutScanConfigsScanConfigIDJSONRequestBody defines body for PutScanConfigsScanConfigID for application/json ContentType.
type PutScanConfigsScanConfigIDJSONRequestBody = ScanConfig

// PostScanEstimationsJSONRequestBody defines body for PostScanEstimations for application/json ContentType.
type PostScanEstimationsJSONRequestBody = ScanEstimation

// PatchScanEstimationsScanEstimationIDJSONRequestBody defines body for PatchScanEstimationsScanEstimationID for application/json ContentType.
type PatchScanEstimationsScanEstimationIDJSONRequestBody = ScanEstimation

// PutScanEstimationsScanEstimationIDJSONRequestBody defines body for PutScanEstimationsScanEstimationID for application/json ContentType.
type PutScanEstimationsScanEstimationIDJSONRequestBody = ScanEstimation

// PostScansJSONRequestBody defines body for PostScans for application/json ContentType.
type PostScansJSONRequestBody = Scan

// PatchScansScanIDJSONRequestBody defines body for PatchScansScanID for application/json ContentType.
type PatchScansScanIDJSONRequestBody = Scan

// PutScansScanIDJSONRequestBody defines body for PutScansScanID for application/json ContentType.
type PutScansScanIDJSONRequestBody = Scan

// AsVMInfo returns the union data inside the AssetType as a VMInfo
func (t AssetType) AsVMInfo() (VMInfo, error) {
	var body VMInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMInfo overwrites any union data inside the AssetType as the provided VMInfo
func (t *AssetType) FromVMInfo(v VMInfo) error {
	v.ObjectType = "VMInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMInfo performs a merge with any union data inside the AssetType, using the provided VMInfo
func (t *AssetType) MergeVMInfo(v VMInfo) error {
	v.ObjectType = "VMInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPodInfo returns the union data inside the AssetType as a PodInfo
func (t AssetType) AsPodInfo() (PodInfo, error) {
	var body PodInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPodInfo overwrites any union data inside the AssetType as the provided PodInfo
func (t *AssetType) FromPodInfo(v PodInfo) error {
	v.ObjectType = "PodInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePodInfo performs a merge with any union data inside the AssetType, using the provided PodInfo
func (t *AssetType) MergePodInfo(v PodInfo) error {
	v.ObjectType = "PodInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDirInfo returns the union data inside the AssetType as a DirInfo
func (t AssetType) AsDirInfo() (DirInfo, error) {
	var body DirInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDirInfo overwrites any union data inside the AssetType as the provided DirInfo
func (t *AssetType) FromDirInfo(v DirInfo) error {
	v.ObjectType = "DirInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDirInfo performs a merge with any union data inside the AssetType, using the provided DirInfo
func (t *AssetType) MergeDirInfo(v DirInfo) error {
	v.ObjectType = "DirInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerImageInfo returns the union data inside the AssetType as a ContainerImageInfo
func (t AssetType) AsContainerImageInfo() (ContainerImageInfo, error) {
	var body ContainerImageInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerImageInfo overwrites any union data inside the AssetType as the provided ContainerImageInfo
func (t *AssetType) FromContainerImageInfo(v ContainerImageInfo) error {
	v.ObjectType = "ContainerImageInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerImageInfo performs a merge with any union data inside the AssetType, using the provided ContainerImageInfo
func (t *AssetType) MergeContainerImageInfo(v ContainerImageInfo) error {
	v.ObjectType = "ContainerImageInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerInfo returns the union data inside the AssetType as a ContainerInfo
func (t AssetType) AsContainerInfo() (ContainerInfo, error) {
	var body ContainerInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerInfo overwrites any union data inside the AssetType as the provided ContainerInfo
func (t *AssetType) FromContainerInfo(v ContainerInfo) error {
	v.ObjectType = "ContainerInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerInfo performs a merge with any union data inside the AssetType, using the provided ContainerInfo
func (t *AssetType) MergeContainerInfo(v ContainerInfo) error {
	v.ObjectType = "ContainerInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AssetType) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"objectType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AssetType) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ContainerImageInfo":
		return t.AsContainerImageInfo()
	case "ContainerInfo":
		return t.AsContainerInfo()
	case "DirInfo":
		return t.AsDirInfo()
	case "PodInfo":
		return t.AsPodInfo()
	case "VMInfo":
		return t.AsVMInfo()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AssetType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AssetType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPackageFindingInfo returns the union data inside the FindingInfo as a PackageFindingInfo
func (t FindingInfo) AsPackageFindingInfo() (PackageFindingInfo, error) {
	var body PackageFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageFindingInfo overwrites any union data inside the FindingInfo as the provided PackageFindingInfo
func (t *FindingInfo) FromPackageFindingInfo(v PackageFindingInfo) error {
	v.ObjectType = "Package"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageFindingInfo performs a merge with any union data inside the FindingInfo, using the provided PackageFindingInfo
func (t *FindingInfo) MergePackageFindingInfo(v PackageFindingInfo) error {
	v.ObjectType = "Package"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnerabilityFindingInfo returns the union data inside the FindingInfo as a VulnerabilityFindingInfo
func (t FindingInfo) AsVulnerabilityFindingInfo() (VulnerabilityFindingInfo, error) {
	var body VulnerabilityFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnerabilityFindingInfo overwrites any union data inside the FindingInfo as the provided VulnerabilityFindingInfo
func (t *FindingInfo) FromVulnerabilityFindingInfo(v VulnerabilityFindingInfo) error {
	v.ObjectType = "Vulnerability"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnerabilityFindingInfo performs a merge with any union data inside the FindingInfo, using the provided VulnerabilityFindingInfo
func (t *FindingInfo) MergeVulnerabilityFindingInfo(v VulnerabilityFindingInfo) error {
	v.ObjectType = "Vulnerability"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMalwareFindingInfo returns the union data inside the FindingInfo as a MalwareFindingInfo
func (t FindingInfo) AsMalwareFindingInfo() (MalwareFindingInfo, error) {
	var body MalwareFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMalwareFindingInfo overwrites any union data inside the FindingInfo as the provided MalwareFindingInfo
func (t *FindingInfo) FromMalwareFindingInfo(v MalwareFindingInfo) error {
	v.ObjectType = "Malware"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMalwareFindingInfo performs a merge with any union data inside the FindingInfo, using the provided MalwareFindingInfo
func (t *FindingInfo) MergeMalwareFindingInfo(v MalwareFindingInfo) error {
	v.ObjectType = "Malware"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecretFindingInfo returns the union data inside the FindingInfo as a SecretFindingInfo
func (t FindingInfo) AsSecretFindingInfo() (SecretFindingInfo, error) {
	var body SecretFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecretFindingInfo overwrites any union data inside the FindingInfo as the provided SecretFindingInfo
func (t *FindingInfo) FromSecretFindingInfo(v SecretFindingInfo) error {
	v.ObjectType = "Secret"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecretFindingInfo performs a merge with any union data inside the FindingInfo, using the provided SecretFindingInfo
func (t *FindingInfo) MergeSecretFindingInfo(v SecretFindingInfo) error {
	v.ObjectType = "Secret"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMisconfigurationFindingInfo returns the union data inside the FindingInfo as a MisconfigurationFindingInfo
func (t FindingInfo) AsMisconfigurationFindingInfo() (MisconfigurationFindingInfo, error) {
	var body MisconfigurationFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMisconfigurationFindingInfo overwrites any union data inside the FindingInfo as the provided MisconfigurationFindingInfo
func (t *FindingInfo) FromMisconfigurationFindingInfo(v MisconfigurationFindingInfo) error {
	v.ObjectType = "Misconfiguration"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMisconfigurationFindingInfo performs a merge with any union data inside the FindingInfo, using the provided MisconfigurationFindingInfo
func (t *FindingInfo) MergeMisconfigurationFindingInfo(v MisconfigurationFindingInfo) error {
	v.ObjectType = "Misconfiguration"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRootkitFindingInfo returns the union data inside the FindingInfo as a RootkitFindingInfo
func (t FindingInfo) AsRootkitFindingInfo() (RootkitFindingInfo, error) {
	var body RootkitFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRootkitFindingInfo overwrites any union data inside the FindingInfo as the provided RootkitFindingInfo
func (t *FindingInfo) FromRootkitFindingInfo(v RootkitFindingInfo) error {
	v.ObjectType = "Rootkit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRootkitFindingInfo performs a merge with any union data inside the FindingInfo, using the provided RootkitFindingInfo
func (t *FindingInfo) MergeRootkitFindingInfo(v RootkitFindingInfo) error {
	v.ObjectType = "Rootkit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsExploitFindingInfo returns the union data inside the FindingInfo as a ExploitFindingInfo
func (t FindingInfo) AsExploitFindingInfo() (ExploitFindingInfo, error) {
	var body ExploitFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExploitFindingInfo overwrites any union data inside the FindingInfo as the provided ExploitFindingInfo
func (t *FindingInfo) FromExploitFindingInfo(v ExploitFindingInfo) error {
	v.ObjectType = "Exploit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExploitFindingInfo performs a merge with any union data inside the FindingInfo, using the provided ExploitFindingInfo
func (t *FindingInfo) MergeExploitFindingInfo(v ExploitFindingInfo) error {
	v.ObjectType = "Exploit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInfoFinderFindingInfo returns the union data inside the FindingInfo as a InfoFinderFindingInfo
func (t FindingInfo) AsInfoFinderFindingInfo() (InfoFinderFindingInfo, error) {
	var body InfoFinderFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInfoFinderFindingInfo overwrites any union data inside the FindingInfo as the provided InfoFinderFindingInfo
func (t *FindingInfo) FromInfoFinderFindingInfo(v InfoFinderFindingInfo) error {
	v.ObjectType = "InfoFinder"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInfoFinderFindingInfo performs a merge with any union data inside the FindingInfo, using the provided InfoFinderFindingInfo
func (t *FindingInfo) MergeInfoFinderFindingInfo(v InfoFinderFindingInfo) error {
	v.ObjectType = "InfoFinder"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FindingInfo) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"objectType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t FindingInfo) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "Exploit":
		return t.AsExploitFindingInfo()
	case "InfoFinder":
		return t.AsInfoFinderFindingInfo()
	case "Malware":
		return t.AsMalwareFindingInfo()
	case "Misconfiguration":
		return t.AsMisconfigurationFindingInfo()
	case "Package":
		return t.AsPackageFindingInfo()
	case "Rootkit":
		return t.AsRootkitFindingInfo()
	case "Secret":
		return t.AsSecretFindingInfo()
	case "Vulnerability":
		return t.AsVulnerabilityFindingInfo()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t FindingInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FindingInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
