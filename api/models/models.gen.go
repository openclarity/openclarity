// Package models provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package models

import (
	"encoding/json"
	"errors"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for AssetScanEstimationStateState.
const (
	AssetScanEstimationStateStateAborted AssetScanEstimationStateState = "Aborted"
	AssetScanEstimationStateStateDone    AssetScanEstimationStateState = "Done"
	AssetScanEstimationStateStateFailed  AssetScanEstimationStateState = "Failed"
	AssetScanEstimationStateStatePending AssetScanEstimationStateState = "Pending"
)

// Defines values for AssetScanEstimationStateStateReason.
const (
	AssetScanEstimationStateStateReasonAborted    AssetScanEstimationStateStateReason = "Aborted"
	AssetScanEstimationStateStateReasonSuccess    AssetScanEstimationStateStateReason = "Success"
	AssetScanEstimationStateStateReasonTimedOut   AssetScanEstimationStateStateReason = "TimedOut"
	AssetScanEstimationStateStateReasonUnexpected AssetScanEstimationStateStateReason = "Unexpected"
)

// Defines values for AssetScanStateState.
const (
	AssetScanStateStateAborted     AssetScanStateState = "Aborted"
	AssetScanStateStateDone        AssetScanStateState = "Done"
	AssetScanStateStateInProgress  AssetScanStateState = "InProgress"
	AssetScanStateStateNotScanned  AssetScanStateState = "NotScanned"
	AssetScanStateStatePending     AssetScanStateState = "Pending"
	AssetScanStateStateReadyToScan AssetScanStateState = "ReadyToScan"
	AssetScanStateStateScheduled   AssetScanStateState = "Scheduled"
)

// Defines values for CloudProvider.
const (
	AWS        CloudProvider = "AWS"
	Azure      CloudProvider = "Azure"
	Docker     CloudProvider = "Docker"
	External   CloudProvider = "External"
	GCP        CloudProvider = "GCP"
	Kubernetes CloudProvider = "Kubernetes"
)

// Defines values for InfoType.
const (
	InfoTypeSSHAuthorizedKeyFingerprint InfoType = "SSHAuthorizedKeyFingerprint"
	InfoTypeSSHDaemonKeyFingerprint     InfoType = "SSHDaemonKeyFingerprint"
	InfoTypeSSHKnownHostFingerprint     InfoType = "SSHKnownHostFingerprint"
	InfoTypeSSHPrivateKeyFingerprint    InfoType = "SSHPrivateKeyFingerprint"
	InfoTypeUNKNOWN                     InfoType = "UNKNOWN"
)

// Defines values for MisconfigurationSeverity.
const (
	MisconfigurationHighSeverity   MisconfigurationSeverity = "MisconfigurationHighSeverity"
	MisconfigurationLowSeverity    MisconfigurationSeverity = "MisconfigurationLowSeverity"
	MisconfigurationMediumSeverity MisconfigurationSeverity = "MisconfigurationMediumSeverity"
)

// Defines values for ProviderStatusReason.
const (
	HeartbeatReceived   ProviderStatusReason = "HeartbeatReceived"
	NoHeartbeatReceived ProviderStatusReason = "NoHeartbeatReceived"
)

// Defines values for ProviderStatusState.
const (
	ProviderStatusStateHealthy   ProviderStatusState = "Healthy"
	ProviderStatusStateUnhealthy ProviderStatusState = "Unhealthy"
	ProviderStatusStateUnknown   ProviderStatusState = "Unknown"
)

// Defines values for ResourceCleanupStatusReason.
const (
	ResourceCleanupStatusReasonAssetScanCreated ResourceCleanupStatusReason = "AssetScanCreated"
	ResourceCleanupStatusReasonDeletePolicy     ResourceCleanupStatusReason = "DeletePolicy"
	ResourceCleanupStatusReasonInternalError    ResourceCleanupStatusReason = "InternalError"
	ResourceCleanupStatusReasonNotApplicable    ResourceCleanupStatusReason = "NotApplicable"
	ResourceCleanupStatusReasonProviderError    ResourceCleanupStatusReason = "ProviderError"
	ResourceCleanupStatusReasonSuccess          ResourceCleanupStatusReason = "Success"
)

// Defines values for ResourceCleanupStatusState.
const (
	ResourceCleanupStatusStateDone    ResourceCleanupStatusState = "Done"
	ResourceCleanupStatusStateFailed  ResourceCleanupStatusState = "Failed"
	ResourceCleanupStatusStatePending ResourceCleanupStatusState = "Pending"
	ResourceCleanupStatusStateSkipped ResourceCleanupStatusState = "Skipped"
)

// Defines values for RootVolumeEncrypted.
const (
	RootVolumeEncryptedNo      RootVolumeEncrypted = "No"
	RootVolumeEncryptedUnknown RootVolumeEncrypted = "Unknown"
	RootVolumeEncryptedYes     RootVolumeEncrypted = "Yes"
)

// Defines values for RootkitType.
const (
	RootkitTypeAPPLICATION RootkitType = "APPLICATION"
	RootkitTypeFIRMWARE    RootkitType = "FIRMWARE"
	RootkitTypeKERNEL      RootkitType = "KERNEL"
	RootkitTypeMEMORY      RootkitType = "MEMORY"
	RootkitTypeUNKNOWN     RootkitType = "UNKNOWN"
)

// Defines values for ScanState.
const (
	ScanStateAborted    ScanState = "Aborted"
	ScanStateDiscovered ScanState = "Discovered"
	ScanStateDone       ScanState = "Done"
	ScanStateFailed     ScanState = "Failed"
	ScanStateInProgress ScanState = "InProgress"
	ScanStatePending    ScanState = "Pending"
)

// Defines values for ScanStateReason.
const (
	ScanStateReasonAborted                    ScanStateReason = "Aborted"
	ScanStateReasonDiscoveryFailed            ScanStateReason = "DiscoveryFailed"
	ScanStateReasonNothingToScan              ScanStateReason = "NothingToScan"
	ScanStateReasonOneOrMoreAssetFailedToScan ScanStateReason = "OneOrMoreAssetFailedToScan"
	ScanStateReasonSuccess                    ScanStateReason = "Success"
	ScanStateReasonTimedOut                   ScanStateReason = "TimedOut"
	ScanStateReasonUnexpected                 ScanStateReason = "Unexpected"
)

// Defines values for ScanEstimationStateState.
const (
	ScanEstimationStateStateAborted    ScanEstimationStateState = "Aborted"
	ScanEstimationStateStateDiscovered ScanEstimationStateState = "Discovered"
	ScanEstimationStateStateDone       ScanEstimationStateState = "Done"
	ScanEstimationStateStateFailed     ScanEstimationStateState = "Failed"
	ScanEstimationStateStateInProgress ScanEstimationStateState = "InProgress"
	ScanEstimationStateStatePending    ScanEstimationStateState = "Pending"
)

// Defines values for ScanEstimationStateStateReason.
const (
	ScanEstimationStateStateReasonAborted                        ScanEstimationStateStateReason = "Aborted"
	ScanEstimationStateStateReasonDiscoveryFailed                ScanEstimationStateStateReason = "DiscoveryFailed"
	ScanEstimationStateStateReasonNothingToEstimate              ScanEstimationStateStateReason = "NothingToEstimate"
	ScanEstimationStateStateReasonOneOrMoreAssetFailedToEstimate ScanEstimationStateStateReason = "OneOrMoreAssetFailedToEstimate"
	ScanEstimationStateStateReasonSuccess                        ScanEstimationStateStateReason = "Success"
	ScanEstimationStateStateReasonTimedOut                       ScanEstimationStateStateReason = "TimedOut"
	ScanEstimationStateStateReasonUnexpected                     ScanEstimationStateStateReason = "Unexpected"
)

// Defines values for ScanRelationshipState.
const (
	ScanRelationshipStateAborted    ScanRelationshipState = "Aborted"
	ScanRelationshipStateDiscovered ScanRelationshipState = "Discovered"
	ScanRelationshipStateDone       ScanRelationshipState = "Done"
	ScanRelationshipStateFailed     ScanRelationshipState = "Failed"
	ScanRelationshipStateInProgress ScanRelationshipState = "InProgress"
	ScanRelationshipStatePending    ScanRelationshipState = "Pending"
)

// Defines values for ScanRelationshipStateReason.
const (
	ScanRelationshipStateReasonAborted                    ScanRelationshipStateReason = "Aborted"
	ScanRelationshipStateReasonDiscoveryFailed            ScanRelationshipStateReason = "DiscoveryFailed"
	ScanRelationshipStateReasonNothingToScan              ScanRelationshipStateReason = "NothingToScan"
	ScanRelationshipStateReasonOneOrMoreAssetFailedToScan ScanRelationshipStateReason = "OneOrMoreAssetFailedToScan"
	ScanRelationshipStateReasonSuccess                    ScanRelationshipStateReason = "Success"
	ScanRelationshipStateReasonTimedOut                   ScanRelationshipStateReason = "TimedOut"
	ScanRelationshipStateReasonUnexpected                 ScanRelationshipStateReason = "Unexpected"
)

// Defines values for ScanType.
const (
	EXPLOIT          ScanType = "EXPLOIT"
	INFOFINDER       ScanType = "INFOFINDER"
	MALWARE          ScanType = "MALWARE"
	MISCONFIGURATION ScanType = "MISCONFIGURATION"
	ROOTKIT          ScanType = "ROOTKIT"
	SBOM             ScanType = "SBOM"
	SECRET           ScanType = "SECRET"
	VULNERABILITY    ScanType = "VULNERABILITY"
)

// Defines values for ScannerStatusReason.
const (
	ScannerStatusReasonError        ScannerStatusReason = "Error"
	ScannerStatusReasonNotScheduled ScannerStatusReason = "NotScheduled"
	ScannerStatusReasonScanning     ScannerStatusReason = "Scanning"
	ScannerStatusReasonScheduled    ScannerStatusReason = "Scheduled"
	ScannerStatusReasonSuccess      ScannerStatusReason = "Success"
)

// Defines values for ScannerStatusState.
const (
	ScannerStatusStateDone       ScannerStatusState = "Done"
	ScannerStatusStateFailed     ScannerStatusState = "Failed"
	ScannerStatusStateInProgress ScannerStatusState = "InProgress"
	ScannerStatusStatePending    ScannerStatusState = "Pending"
	ScannerStatusStateSkipped    ScannerStatusState = "Skipped"
)

// Defines values for VulnerabilitySeverity.
const (
	CRITICAL   VulnerabilitySeverity = "CRITICAL"
	HIGH       VulnerabilitySeverity = "HIGH"
	LOW        VulnerabilitySeverity = "LOW"
	MEDIUM     VulnerabilitySeverity = "MEDIUM"
	NEGLIGIBLE VulnerabilitySeverity = "NEGLIGIBLE"
)

// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
type Annotations = []struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// ApiResponse An object that is returned in all cases of failures.
type ApiResponse struct {
	Message *string `json:"message,omitempty"`
}

// Asset defines model for Asset.
type Asset struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`
	AssetInfo   *AssetType   `json:"assetInfo,omitempty"`
	FirstSeen   *time.Time   `json:"firstSeen,omitempty"`
	Id          *string      `json:"id,omitempty"`
	LastSeen    *time.Time   `json:"lastSeen,omitempty"`

	// Providers List of providers which discover the asset.
	Providers *[]ProviderRelationship `json:"providers,omitempty"`
	Revision  *int                    `json:"revision,omitempty"`

	// ScansCount Total number of scans that have ever run for this asset
	ScansCount *int `json:"scansCount,omitempty"`

	// Summary A summary of the scan findings.
	Summary      *ScanFindingsSummary `json:"summary,omitempty"`
	TerminatedOn *time.Time           `json:"terminatedOn,omitempty"`
}

// AssetCommon defines model for AssetCommon.
type AssetCommon = map[string]interface{}

// AssetExists defines model for AssetExists.
type AssetExists struct {
	// Asset Describes an asset object.
	Asset *Asset `json:"asset,omitempty"`

	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`
}

// AssetRelationship defines model for AssetRelationship.
type AssetRelationship struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`
	AssetInfo   *AssetType   `json:"assetInfo,omitempty"`
	FirstSeen   *time.Time   `json:"firstSeen,omitempty"`
	Id          string       `json:"id"`
	LastSeen    *time.Time   `json:"lastSeen,omitempty"`

	// Providers List of providers which discover the asset.
	Providers *[]ProviderRelationship `json:"providers,omitempty"`
	Revision  *int                    `json:"revision,omitempty"`

	// ScansCount Total number of scans that have ever run for this asset
	ScansCount *int `json:"scansCount,omitempty"`

	// Summary A summary of the scan findings.
	Summary      *ScanFindingsSummary `json:"summary,omitempty"`
	TerminatedOn *time.Time           `json:"terminatedOn,omitempty"`
}

// AssetScan defines model for AssetScan.
type AssetScan struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Asset Describes a relationship to an asset which can be expanded.
	Asset             *AssetRelationship    `json:"asset,omitempty"`
	Exploits          *ExploitScan          `json:"exploits,omitempty"`
	FindingsProcessed *bool                 `json:"findingsProcessed,omitempty"`
	Id                *string               `json:"id,omitempty"`
	InfoFinder        *InfoFinderScan       `json:"infoFinder,omitempty"`
	Malware           *MalwareScan          `json:"malware,omitempty"`
	Misconfigurations *MisconfigurationScan `json:"misconfigurations,omitempty"`

	// Provider Describes a relationship to a provider which can be expanded.
	Provider              *ProviderRelationship  `json:"provider,omitempty"`
	ResourceCleanupStatus *ResourceCleanupStatus `json:"resourceCleanupStatus,omitempty"`
	Revision              *int                   `json:"revision,omitempty"`
	Rootkits              *RootkitScan           `json:"rootkits,omitempty"`
	Sbom                  *SbomScan              `json:"sbom,omitempty"`

	// Scan Describes an expandable relationship to Scan object
	Scan *ScanRelationship `json:"scan,omitempty"`

	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig `json:"scanFamiliesConfig,omitempty"`

	// ScannerInstanceCreationConfig Configuration of scanner instance
	ScannerInstanceCreationConfig *ScannerInstanceCreationConfig `json:"scannerInstanceCreationConfig,omitempty"`
	Secrets                       *SecretScan                    `json:"secrets,omitempty"`
	Stats                         *AssetScanStats                `json:"stats,omitempty"`
	Status                        *AssetScanStatus               `json:"status,omitempty"`

	// Summary A summary of the scan findings.
	Summary         *ScanFindingsSummary `json:"summary,omitempty"`
	Vulnerabilities *VulnerabilityScan   `json:"vulnerabilities,omitempty"`
}

// AssetScanEstimation defines model for AssetScanEstimation.
type AssetScanEstimation struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Asset Describes a relationship to an asset which can be expanded.
	Asset             *AssetRelationship `json:"asset,omitempty"`
	AssetScanTemplate *AssetScanTemplate `json:"assetScanTemplate,omitempty"`

	// DeleteAfter The time this resource should be deleted. This value is calculated by endTime + ttlSecondsAfterFinished. This should not be set by the user, but use ttlSecondsAfterFinished instead.
	DeleteAfter    *time.Time                  `json:"deleteAfter,omitempty"`
	EndTime        *time.Time                  `json:"endTime,omitempty"`
	Estimation     *Estimation                 `json:"estimation,omitempty"`
	Id             *string                     `json:"id,omitempty"`
	Revision       *int                        `json:"revision,omitempty"`
	ScanEstimation *ScanEstimationRelationship `json:"scanEstimation,omitempty"`
	StartTime      *time.Time                  `json:"startTime,omitempty"`
	State          *AssetScanEstimationState   `json:"state,omitempty"`

	// TtlSecondsAfterFinished The duration in seconds this resource should last until it is deleted.
	TTLSecondsAfterFinished *int `json:"ttlSecondsAfterFinished,omitempty"`
}

// AssetScanEstimationExists defines model for AssetScanEstimationExists.
type AssetScanEstimationExists struct {
	AssetScanEstimation *AssetScanEstimation `json:"assetScanEstimation,omitempty"`

	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`
}

// AssetScanEstimationRelationship defines model for AssetScanEstimationRelationship.
type AssetScanEstimationRelationship struct {
	Id *string `json:"id,omitempty"`
}

// AssetScanEstimationState defines model for AssetScanEstimationState.
type AssetScanEstimationState struct {
	LastTransitionTime *time.Time                     `json:"lastTransitionTime,omitempty"`
	State              *AssetScanEstimationStateState `json:"state,omitempty"`

	// StateMessage Human-readable message indicating details about the last state transition.
	StateMessage *string `json:"stateMessage,omitempty"`

	// StateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
	StateReason *AssetScanEstimationStateStateReason `json:"stateReason,omitempty"`
}

// AssetScanEstimationStateState defines model for AssetScanEstimationState.State.
type AssetScanEstimationStateState string

// AssetScanEstimationStateStateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
type AssetScanEstimationStateStateReason string

// AssetScanEstimations defines model for AssetScanEstimations.
type AssetScanEstimations struct {
	// Count Total AssetScanEstimations count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of AssetScanEstimations according to the given filters
	Items *[]AssetScanEstimation `json:"items,omitempty"`
}

// AssetScanExists defines model for AssetScanExists.
type AssetScanExists struct {
	AssetScan *AssetScan `json:"assetScan,omitempty"`

	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`
}

// AssetScanGeneralStats Global statistics for asset scan of all families.
type AssetScanGeneralStats struct {
	ScanTime *AssetScanScanTime `json:"scanTime,omitempty"`
}

// AssetScanInputScanStats Statistics per asset scan input.
type AssetScanInputScanStats struct {
	// Path The input path (/mnt/snapshot for ex.)
	Path     *string            `json:"path,omitempty"`
	ScanTime *AssetScanScanTime `json:"scanTime,omitempty"`

	// Size The input size in MB.
	Size *int64 `json:"size,omitempty"`

	// Type The input type (ROOTFS, DIR, IMAGE etc.)
	Type *string `json:"type,omitempty"`
}

// AssetScanRelationship defines model for AssetScanRelationship.
type AssetScanRelationship struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Asset Describes a relationship to an asset which can be expanded.
	Asset                 *AssetRelationship     `json:"asset,omitempty"`
	Exploits              *ExploitScan           `json:"exploits,omitempty"`
	FindingsProcessed     *bool                  `json:"findingsProcessed,omitempty"`
	Id                    string                 `json:"id"`
	InfoFinder            *InfoFinderScan        `json:"infoFinder,omitempty"`
	Malware               *MalwareScan           `json:"malware,omitempty"`
	Misconfigurations     *MisconfigurationScan  `json:"misconfigurations,omitempty"`
	ResourceCleanupStatus *ResourceCleanupStatus `json:"resourceCleanupStatus,omitempty"`
	Revision              *int                   `json:"revision,omitempty"`
	Rootkits              *RootkitScan           `json:"rootkits,omitempty"`
	Sbom                  *SbomScan              `json:"sbom,omitempty"`

	// Scan Describes an expandable relationship to Scan object
	Scan *ScanRelationship `json:"scan,omitempty"`

	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig `json:"scanFamiliesConfig,omitempty"`

	// ScannerInstanceCreationConfig Configuration of scanner instance
	ScannerInstanceCreationConfig *ScannerInstanceCreationConfig `json:"scannerInstanceCreationConfig,omitempty"`
	Secrets                       *SecretScan                    `json:"secrets,omitempty"`
	Stats                         *AssetScanStats                `json:"stats,omitempty"`
	Status                        *AssetScanStatus               `json:"status,omitempty"`

	// Summary A summary of the scan findings.
	Summary         *ScanFindingsSummary `json:"summary,omitempty"`
	Vulnerabilities *VulnerabilityScan   `json:"vulnerabilities,omitempty"`
}

// AssetScanScanTime defines model for AssetScanScanTime.
type AssetScanScanTime struct {
	EndTime   *time.Time `json:"endTime,omitempty"`
	StartTime *time.Time `json:"startTime,omitempty"`
}

// AssetScanState defines model for AssetScanState.
type AssetScanState struct {
	Errors             *[]string            `json:"errors"`
	LastTransitionTime *time.Time           `json:"lastTransitionTime,omitempty"`
	State              *AssetScanStateState `json:"state,omitempty"`
}

// AssetScanStateState defines model for AssetScanState.State.
type AssetScanStateState string

// AssetScanStats defines model for AssetScanStats.
type AssetScanStats struct {
	Exploits *[]AssetScanInputScanStats `json:"exploits,omitempty"`

	// General Global statistics for asset scan of all families.
	General           *AssetScanGeneralStats     `json:"general,omitempty"`
	InfoFinder        *[]AssetScanInputScanStats `json:"infoFinder,omitempty"`
	Malware           *[]AssetScanInputScanStats `json:"malware,omitempty"`
	Misconfigurations *[]AssetScanInputScanStats `json:"misconfigurations,omitempty"`
	Rootkits          *[]AssetScanInputScanStats `json:"rootkits,omitempty"`
	Sbom              *[]AssetScanInputScanStats `json:"sbom,omitempty"`
	Secrets           *[]AssetScanInputScanStats `json:"secrets,omitempty"`
	Vulnerabilities   *[]AssetScanInputScanStats `json:"vulnerabilities,omitempty"`
}

// AssetScanStatus defines model for AssetScanStatus.
type AssetScanStatus struct {
	General *AssetScanState `json:"general,omitempty"`
}

// AssetScanTemplate defines model for AssetScanTemplate.
type AssetScanTemplate struct {
	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig `json:"scanFamiliesConfig,omitempty"`

	// ScannerInstanceCreationConfig Configuration of scanner instance
	ScannerInstanceCreationConfig *ScannerInstanceCreationConfig `json:"scannerInstanceCreationConfig,omitempty"`
}

// AssetScanTemplateReadOnly defines model for AssetScanTemplateReadOnly.
type AssetScanTemplateReadOnly struct {
	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig `json:"scanFamiliesConfig,omitempty"`

	// ScannerInstanceCreationConfig Configuration of scanner instance
	ScannerInstanceCreationConfig *ScannerInstanceCreationConfig `json:"scannerInstanceCreationConfig,omitempty"`
}

// AssetScans defines model for AssetScans.
type AssetScans struct {
	// Count Total asset scans count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of asset scans according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]AssetScan `json:"items,omitempty"`
}

// AssetType defines model for AssetType.
type AssetType struct {
	union json.RawMessage
}

// Assets defines model for Assets.
type Assets struct {
	// Count Total assets count according the given filters
	Count *int `json:"count,omitempty"`

	// Items List of assets in the given filters and page. List length must be lower or equal to pageSize.
	Items *[]Asset `json:"items,omitempty"`
}

// CloudProvider defines model for CloudProvider.
type CloudProvider string

// ContainerImageInfo defines model for ContainerImageInfo.
type ContainerImageInfo struct {
	Architecture *string   `json:"architecture,omitempty"`
	ImageID      string    `json:"imageID"`
	Labels       *[]Tag    `json:"labels"`
	ObjectType   string    `json:"objectType"`
	Os           *string   `json:"os,omitempty"`
	RepoDigests  *[]string `json:"repoDigests,omitempty"`
	RepoTags     *[]string `json:"repoTags,omitempty"`
	Size         *int      `json:"size,omitempty"`
}

// ContainerInfo defines model for ContainerInfo.
type ContainerInfo struct {
	ContainerID   string              `json:"containerID"`
	ContainerName *string             `json:"containerName,omitempty"`
	CreatedAt     *time.Time          `json:"createdAt,omitempty"`
	Image         *ContainerImageInfo `json:"image,omitempty"`
	Labels        *[]Tag              `json:"labels"`
	Location      *string             `json:"location,omitempty"`
	ObjectType    string              `json:"objectType"`
}

// CostBreakdownComponent defines model for CostBreakdownComponent.
type CostBreakdownComponent struct {
	Cost      float32 `json:"cost"`
	Operation string  `json:"operation"`
}

// DirInfo defines model for DirInfo.
type DirInfo struct {
	DirName    *string `json:"dirName,omitempty"`
	Location   *string `json:"location,omitempty"`
	ObjectType string  `json:"objectType"`
}

// Estimation defines model for Estimation.
type Estimation struct {
	// Cost The estimated scan cost ($)
	Cost          *float32                  `json:"cost,omitempty"`
	CostBreakdown *[]CostBreakdownComponent `json:"costBreakdown,omitempty"`

	// Duration The estimated scan duration (seconds)
	Duration *int `json:"duration,omitempty"`

	// Size The estimated scan size (GB)
	Size *int `json:"size,omitempty"`
}

// Exploit defines model for Exploit.
type Exploit struct {
	CveID       *string   `json:"cveID,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	SourceDB    *string   `json:"sourceDB,omitempty"`
	Title       *string   `json:"title,omitempty"`
	Urls        *[]string `json:"urls"`
}

// ExploitFindingInfo defines model for ExploitFindingInfo.
type ExploitFindingInfo struct {
	CveID       *string   `json:"cveID,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	ObjectType  string    `json:"objectType"`
	SourceDB    *string   `json:"sourceDB,omitempty"`
	Title       *string   `json:"title,omitempty"`
	Urls        *[]string `json:"urls"`
}

// ExploitScan defines model for ExploitScan.
type ExploitScan struct {
	Exploits *[]Exploit     `json:"exploits"`
	Status   *ScannerStatus `json:"status,omitempty"`
}

// ExploitsConfig defines model for ExploitsConfig.
type ExploitsConfig struct {
	Enabled  *bool     `json:"enabled,omitempty"`
	Scanners *[]string `json:"scanners,omitempty"`
}

// Finding defines model for Finding.
type Finding struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Asset Describes a relationship to an asset which can be expanded.
	Asset       *AssetRelationship     `json:"asset,omitempty"`
	FindingInfo *Finding_FindingInfo   `json:"findingInfo,omitempty"`
	FoundBy     *AssetScanRelationship `json:"foundBy,omitempty"`

	// FoundOn When this finding was discovered by a scan
	FoundOn *time.Time `json:"foundOn,omitempty"`
	Id      *string    `json:"id,omitempty"`

	// InvalidatedOn When this finding was invalidated by a newer scan
	InvalidatedOn *time.Time `json:"invalidatedOn,omitempty"`
}

// Finding_FindingInfo defines model for Finding.FindingInfo.
type Finding_FindingInfo struct {
	union json.RawMessage
}

// FindingExists defines model for FindingExists.
type FindingExists struct {
	Finding *Finding `json:"finding,omitempty"`

	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`
}

// Findings defines model for Findings.
type Findings struct {
	// Count Total findings count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of findings according to the given filters
	Items *[]Finding `json:"items,omitempty"`
}

// InfoFinderConfig defines model for InfoFinderConfig.
type InfoFinderConfig struct {
	Enabled  *bool     `json:"enabled,omitempty"`
	Scanners *[]string `json:"scanners,omitempty"`
}

// InfoFinderFindingInfo defines model for InfoFinderFindingInfo.
type InfoFinderFindingInfo struct {
	// Data The data found by the scanner in the specific path for a specific type. See example for SSHKnownHostFingerprint info type
	Data       *string `json:"data,omitempty"`
	ObjectType string  `json:"objectType"`

	// Path File path containing the info
	Path        *string   `json:"path,omitempty"`
	ScannerName *string   `json:"scannerName,omitempty"`
	Type        *InfoType `json:"type,omitempty"`
}

// InfoFinderInfo defines model for InfoFinderInfo.
type InfoFinderInfo struct {
	// Data The data found by the scanner in the specific path for a specific type. See example for SSHKnownHostFingerprint info type
	Data *string `json:"data,omitempty"`

	// Path File path containing the info
	Path        *string   `json:"path,omitempty"`
	ScannerName *string   `json:"scannerName,omitempty"`
	Type        *InfoType `json:"type,omitempty"`
}

// InfoFinderScan defines model for InfoFinderScan.
type InfoFinderScan struct {
	Infos    *[]InfoFinderInfo `json:"infos"`
	Scanners *[]string         `json:"scanners"`
	Status   *ScannerStatus    `json:"status,omitempty"`
}

// InfoType defines model for InfoType.
type InfoType string

// Malware defines model for Malware.
type Malware struct {
	MalwareName *string      `json:"malwareName,omitempty"`
	MalwareType *MalwareType `json:"malwareType,omitempty"`

	// Path Path of the file that contains malware
	Path     *string `json:"path,omitempty"`
	RuleName *string `json:"ruleName,omitempty"`
}

// MalwareConfig defines model for MalwareConfig.
type MalwareConfig struct {
	Enabled  *bool     `json:"enabled,omitempty"`
	Scanners *[]string `json:"scanners,omitempty"`
}

// MalwareFindingInfo defines model for MalwareFindingInfo.
type MalwareFindingInfo struct {
	MalwareName *string      `json:"malwareName,omitempty"`
	MalwareType *MalwareType `json:"malwareType,omitempty"`
	ObjectType  string       `json:"objectType"`

	// Path Path of the file that contains malware
	Path     *string `json:"path,omitempty"`
	RuleName *string `json:"ruleName,omitempty"`
}

// MalwareScan defines model for MalwareScan.
type MalwareScan struct {
	Malware  *[]Malware         `json:"malware"`
	Metadata *[]ScannerMetadata `json:"metadata"`
	Status   *ScannerStatus     `json:"status,omitempty"`
}

// MalwareType defines model for MalwareType.
type MalwareType = string

// Metadata defines model for Metadata.
type Metadata struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`
}

// MetadataReadOnly defines model for MetadataReadOnly.
type MetadataReadOnly struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`
}

// Misconfiguration defines model for Misconfiguration.
type Misconfiguration struct {
	Message         *string                   `json:"message,omitempty"`
	Remediation     *string                   `json:"remediation,omitempty"`
	ScannedPath     *string                   `json:"scannedPath,omitempty"`
	ScannerName     *string                   `json:"scannerName,omitempty"`
	Severity        *MisconfigurationSeverity `json:"severity,omitempty"`
	TestCategory    *string                   `json:"testCategory,omitempty"`
	TestDescription *string                   `json:"testDescription,omitempty"`
	TestID          *string                   `json:"testID,omitempty"`
}

// MisconfigurationFindingInfo defines model for MisconfigurationFindingInfo.
type MisconfigurationFindingInfo struct {
	Message         *string                   `json:"message,omitempty"`
	ObjectType      string                    `json:"objectType"`
	Remediation     *string                   `json:"remediation,omitempty"`
	ScannedPath     *string                   `json:"scannedPath,omitempty"`
	ScannerName     *string                   `json:"scannerName,omitempty"`
	Severity        *MisconfigurationSeverity `json:"severity,omitempty"`
	TestCategory    *string                   `json:"testCategory,omitempty"`
	TestDescription *string                   `json:"testDescription,omitempty"`
	TestID          *string                   `json:"testID,omitempty"`
}

// MisconfigurationScan defines model for MisconfigurationScan.
type MisconfigurationScan struct {
	Misconfigurations *[]Misconfiguration `json:"misconfigurations"`
	Scanners          *[]string           `json:"scanners"`
	Status            *ScannerStatus      `json:"status,omitempty"`
}

// MisconfigurationSeverity defines model for MisconfigurationSeverity.
type MisconfigurationSeverity string

// MisconfigurationsConfig defines model for MisconfigurationsConfig.
type MisconfigurationsConfig struct {
	Enabled  *bool     `json:"enabled,omitempty"`
	Scanners *[]string `json:"scanners,omitempty"`
}

// Package defines model for Package.
type Package struct {
	Cpes     *[]string `json:"cpes"`
	Language *string   `json:"language,omitempty"`
	Licenses *[]string `json:"licenses"`
	Name     *string   `json:"name,omitempty"`
	Purl     *string   `json:"purl,omitempty"`
	Type     *string   `json:"type,omitempty"`
	Version  *string   `json:"version,omitempty"`
}

// PackageFindingInfo defines model for PackageFindingInfo.
type PackageFindingInfo struct {
	Cpes       *[]string `json:"cpes"`
	Language   *string   `json:"language,omitempty"`
	Licenses   *[]string `json:"licenses"`
	Name       *string   `json:"name,omitempty"`
	ObjectType string    `json:"objectType"`
	Purl       *string   `json:"purl,omitempty"`
	Type       *string   `json:"type,omitempty"`
	Version    *string   `json:"version,omitempty"`
}

// PodInfo defines model for PodInfo.
type PodInfo struct {
	Location   *string `json:"location,omitempty"`
	ObjectType string  `json:"objectType"`
	PodName    *string `json:"podName,omitempty"`
}

// Provider defines model for Provider.
type Provider struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// DisplayName Human-readable name for the provider.
	DisplayName *string `json:"displayName,omitempty"`
	Id          *string `json:"id,omitempty"`

	// LastHeartbeatTime Timestamp of the last heartbeat from the provider.
	LastHeartbeatTime *time.Time `json:"lastHeartbeatTime,omitempty"`

	// ProviderRuntimeVersion Version of the provider runtime that the provider was compiled with.
	ProviderRuntimeVersion *string         `json:"providerRuntimeVersion,omitempty"`
	Revision               *int            `json:"revision,omitempty"`
	Status                 *ProviderStatus `json:"status,omitempty"`
}

// ProviderExists defines model for ProviderExists.
type ProviderExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`

	// Provider Describes a provider object.
	Provider *Provider `json:"provider,omitempty"`
}

// ProviderRelationship defines model for ProviderRelationship.
type ProviderRelationship struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// DisplayName Human-readable name for the provider.
	DisplayName *string `json:"displayName,omitempty"`
	Id          *string `json:"id,omitempty"`

	// LastHeartbeatTime Timestamp of the last heartbeat from the provider.
	LastHeartbeatTime *time.Time `json:"lastHeartbeatTime,omitempty"`

	// ProviderRuntimeVersion Version of the provider runtime that the provider was compiled with.
	ProviderRuntimeVersion *string         `json:"providerRuntimeVersion,omitempty"`
	Revision               *int            `json:"revision,omitempty"`
	Status                 *ProviderStatus `json:"status,omitempty"`
}

// ProviderStatus defines model for ProviderStatus.
type ProviderStatus struct {
	// LastTransitionTime Last date-time when the status has changed.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message Human-readable message indicating details about the last state transition.
	Message *string `json:"message,omitempty"`

	// Reason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
	Reason ProviderStatusReason `json:"reason"`

	// State Describes the health state of the provider.
	//
	// | State     | Description                                    |
	// | --------- | ---------------------------------------------- |
	// | Healthy   | Provider is healthy.                           |
	// | Unhealthy | Heartbeat received, but Provider is unhealthy. |
	// | Unknown   | No heartbeat received from Provider.           |
	State ProviderStatusState `json:"state"`
}

// ProviderStatusReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
type ProviderStatusReason string

// ProviderStatusState Describes the health state of the provider.
//
// | State     | Description                                    |
// | --------- | ---------------------------------------------- |
// | Healthy   | Provider is healthy.                           |
// | Unhealthy | Heartbeat received, but Provider is unhealthy. |
// | Unknown   | No heartbeat received from Provider.           |
type ProviderStatusState string

// Providers defines model for Providers.
type Providers struct {
	// Count Total providers count according the given filters
	Count *int `json:"count,omitempty"`

	// Items List of providers in the given filters and page. List length must be lower or equal to pageSize.
	Items *[]Provider `json:"items,omitempty"`
}

// ResourceCleanupStatus defines model for ResourceCleanupStatus.
type ResourceCleanupStatus struct {
	// LastTransitionTime Last date time when the status has changed.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message Human readable message.
	Message *string `json:"message,omitempty"`

	// Reason Machine readable reason for state transition.
	//
	// | State   | Reason          | Description                                                            |
	// | ------- | --------------- | ---------------------------------------------------------------------- |
	// | Pending | AssetScanCreate | AssetScan created                                                      |
	// | Skipped | NotApplicable   | Resource cleanup is not required as it is managed outside of VMClarity |
	// | Skipped | DeletePolicy    | Resource cleanup has been skipped due to Delete Job Policy             |
	// | Failed  | ProviderError   | Failed due to Provider error                                           |
	// | Failed  | InternalError   | Failed due to internal error                                           |
	// | Done    | Success         | Successfully completed                                                 |
	Reason ResourceCleanupStatusReason `json:"reason"`

	// State Describes the state of resource cleanup.
	//
	// | State   | Description                                                |
	// | ------- | ---------------------------------------------------------- |
	// | Pending | Initial state for cleaning up resources                    |
	// | Skipped | Resource cleanup has been skipped due to Delete Job Policy |
	// | Failed  | Cleaning up resources has been failed                      |
	// | Done    | Resources have been successfully cleaned up                |
	State ResourceCleanupStatusState `json:"state"`
}

// ResourceCleanupStatusReason Machine readable reason for state transition.
//
// | State   | Reason          | Description                                                            |
// | ------- | --------------- | ---------------------------------------------------------------------- |
// | Pending | AssetScanCreate | AssetScan created                                                      |
// | Skipped | NotApplicable   | Resource cleanup is not required as it is managed outside of VMClarity |
// | Skipped | DeletePolicy    | Resource cleanup has been skipped due to Delete Job Policy             |
// | Failed  | ProviderError   | Failed due to Provider error                                           |
// | Failed  | InternalError   | Failed due to internal error                                           |
// | Done    | Success         | Successfully completed                                                 |
type ResourceCleanupStatusReason string

// ResourceCleanupStatusState Describes the state of resource cleanup.
//
// | State   | Description                                                |
// | ------- | ---------------------------------------------------------- |
// | Pending | Initial state for cleaning up resources                    |
// | Skipped | Resource cleanup has been skipped due to Delete Job Policy |
// | Failed  | Cleaning up resources has been failed                      |
// | Done    | Resources have been successfully cleaned up                |
type ResourceCleanupStatusState string

// RootVolume Information about VM root volume
type RootVolume struct {
	Encrypted RootVolumeEncrypted `json:"encrypted"`
	SizeGB    int                 `json:"sizeGB"`
}

// RootVolumeEncrypted defines model for RootVolume.Encrypted.
type RootVolumeEncrypted string

// Rootkit defines model for Rootkit.
type Rootkit struct {
	Message     *string      `json:"message,omitempty"`
	RootkitName *string      `json:"rootkitName,omitempty"`
	RootkitType *RootkitType `json:"rootkitType,omitempty"`
}

// RootkitFindingInfo defines model for RootkitFindingInfo.
type RootkitFindingInfo struct {
	Message     *string      `json:"message,omitempty"`
	ObjectType  string       `json:"objectType"`
	RootkitName *string      `json:"rootkitName,omitempty"`
	RootkitType *RootkitType `json:"rootkitType,omitempty"`
}

// RootkitScan defines model for RootkitScan.
type RootkitScan struct {
	Rootkits *[]Rootkit     `json:"rootkits"`
	Status   *ScannerStatus `json:"status,omitempty"`
}

// RootkitType defines model for RootkitType.
type RootkitType string

// RootkitsConfig defines model for RootkitsConfig.
type RootkitsConfig struct {
	Enabled  *bool     `json:"enabled,omitempty"`
	Scanners *[]string `json:"scanners,omitempty"`
}

// RuntimeScheduleScanConfig Runtime schedule scan configuration. If only operationTime is set, it will be a single scan scheduled for the operationTime. If only cronLine is set, the current time will be the "from time" to start the scheduling according to the cronLine. If both operationTime and cronLine are set, the first scan will run at operationTime and the operationTime will be the first time that the cronLine will be effective from.
type RuntimeScheduleScanConfig struct {
	// CronLine Cron schedule expressions.
	CronLine *string `json:"cronLine,omitempty"`

	// OperationTime The next time this ScanConfig should trigger a scan.
	OperationTime *time.Time `json:"operationTime,omitempty"`
}

// SBOMConfig defines model for SBOMConfig.
type SBOMConfig struct {
	Analyzers *[]string `json:"analyzers,omitempty"`
	Enabled   *bool     `json:"enabled,omitempty"`
}

// SbomScan defines model for SbomScan.
type SbomScan struct {
	Packages *[]Package     `json:"packages"`
	Status   *ScannerStatus `json:"status,omitempty"`
}

// Scan defines model for Scan.
type Scan struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// AssetIDs List of asset IDs to be scanned
	AssetIDs          *[]string          `json:"assetIDs"`
	AssetScanTemplate *AssetScanTemplate `json:"assetScanTemplate,omitempty"`
	EndTime           *time.Time         `json:"endTime,omitempty"`
	Id                *string            `json:"id,omitempty"`

	// MaxParallelScanners The maximum number of asset scans that can be scheduled in parallel for this scan
	MaxParallelScanners *int    `json:"maxParallelScanners,omitempty"`
	Name                *string `json:"name,omitempty"`
	Revision            *int    `json:"revision,omitempty"`

	// ScanConfig Describes a relationship to a scan config which can be expanded.
	ScanConfig *ScanConfigRelationship `json:"scanConfig,omitempty"`

	// Scope The query used to limit the scope of this scan. It uses
	// the ODATA $filter query language to limit the collection of assets
	// that this scan will operate over. For example
	// `startswith(assetInfo.location, 'eu-west-2')` will limit this scan
	// to just assets in the eu-west-2 AWS region.
	Scope     *string    `json:"scope,omitempty"`
	StartTime *time.Time `json:"startTime,omitempty"`

	// State The lifecycle state of this scan.
	State *ScanState `json:"state,omitempty"`

	// StateMessage Human-readable message indicating details about the last state transition.
	StateMessage *string `json:"stateMessage,omitempty"`

	// StateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
	StateReason *ScanStateReason `json:"stateReason,omitempty"`

	// Summary A summary of the progress of a scan for informational purposes.
	Summary *ScanSummary `json:"summary,omitempty"`

	// TimeoutSeconds The maximum time in seconds that a scan started from this config
	// should run for before being automatically aborted.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// ScanState The lifecycle state of this scan.
type ScanState string

// ScanStateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
type ScanStateReason string

// ScanConfig defines model for ScanConfig.
type ScanConfig struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Disabled if true, the scan config is disabled and no scan should run from it
	Disabled     *bool         `json:"disabled,omitempty"`
	Id           *string       `json:"id,omitempty"`
	Name         *string       `json:"name,omitempty"`
	Revision     *int          `json:"revision,omitempty"`
	ScanTemplate *ScanTemplate `json:"scanTemplate,omitempty"`

	// Scheduled Runtime schedule scan configuration. If only operationTime is set, it will be a single scan scheduled for the operationTime. If only cronLine is set, the current time will be the "from time" to start the scheduling according to the cronLine. If both operationTime and cronLine are set, the first scan will run at operationTime and the operationTime will be the first time that the cronLine will be effective from.
	Scheduled *RuntimeScheduleScanConfig `json:"scheduled,omitempty"`
}

// ScanConfigExists defines model for ScanConfigExists.
type ScanConfigExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`

	// ScanConfig Describes a multi-asset scheduled scan config.
	ScanConfig *ScanConfig `json:"scanConfig,omitempty"`
}

// ScanConfigRelationship defines model for ScanConfigRelationship.
type ScanConfigRelationship struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Disabled if true, the scan config is disabled and no scan should run from it
	Disabled     *bool         `json:"disabled,omitempty"`
	Id           string        `json:"id"`
	Name         *string       `json:"name,omitempty"`
	Revision     *int          `json:"revision,omitempty"`
	ScanTemplate *ScanTemplate `json:"scanTemplate,omitempty"`

	// Scheduled Runtime schedule scan configuration. If only operationTime is set, it will be a single scan scheduled for the operationTime. If only cronLine is set, the current time will be the "from time" to start the scheduling according to the cronLine. If both operationTime and cronLine are set, the first scan will run at operationTime and the operationTime will be the first time that the cronLine will be effective from.
	Scheduled *RuntimeScheduleScanConfig `json:"scheduled,omitempty"`
}

// ScanConfigs defines model for ScanConfigs.
type ScanConfigs struct {
	// Count Total scan config count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of scan configs according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]ScanConfig `json:"items,omitempty"`
}

// ScanEstimation defines model for ScanEstimation.
type ScanEstimation struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// AssetIDs List of asset IDs to be estimated
	AssetIDs *[]string `json:"assetIDs,omitempty"`

	// AssetScanEstimations AssetScanEstimations which make up this ScanEstimation
	AssetScanEstimations *[]AssetScanEstimationRelationship `json:"assetScanEstimations,omitempty"`

	// DeleteAfter The time this resource should be deleted. This value is calculated by endTime + ttlSecondsAfterFinished. This should not be set by the user, but use ttlSecondsAfterFinished instead.
	DeleteAfter  *time.Time           `json:"deleteAfter,omitempty"`
	EndTime      *time.Time           `json:"endTime,omitempty"`
	Id           *string              `json:"id,omitempty"`
	Revision     *int                 `json:"revision,omitempty"`
	ScanTemplate *ScanTemplate        `json:"scanTemplate,omitempty"`
	StartTime    *time.Time           `json:"startTime,omitempty"`
	State        *ScanEstimationState `json:"state,omitempty"`

	// Summary A summary of the AssetScanEstimations under this ScanEstimation
	Summary *ScanEstimationSummary `json:"summary,omitempty"`

	// TtlSecondsAfterFinished The duration in seconds this resource should last until it is deleted.
	TTLSecondsAfterFinished *int `json:"ttlSecondsAfterFinished,omitempty"`
}

// ScanEstimationRelationship defines model for ScanEstimationRelationship.
type ScanEstimationRelationship struct {
	Id *string `json:"id,omitempty"`
}

// ScanEstimationState defines model for ScanEstimationState.
type ScanEstimationState struct {
	// State The lifecycle state of this scan estimation.
	State *ScanEstimationStateState `json:"state,omitempty"`

	// StateMessage Human-readable message indicating details about the last state transition.
	StateMessage *string `json:"stateMessage,omitempty"`

	// StateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
	StateReason *ScanEstimationStateStateReason `json:"stateReason,omitempty"`
}

// ScanEstimationStateState The lifecycle state of this scan estimation.
type ScanEstimationStateState string

// ScanEstimationStateStateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
type ScanEstimationStateStateReason string

// ScanEstimationSummary A summary of the AssetScanEstimations under this ScanEstimation
type ScanEstimationSummary struct {
	JobsCompleted *int `json:"jobsCompleted,omitempty"`
	JobsLeftToRun *int `json:"jobsLeftToRun,omitempty"`

	// TotalScanCost Total estimated cost of the scan ($)
	TotalScanCost *float32 `json:"totalScanCost,omitempty"`

	// TotalScanSize Total estimated size of the scan (GB)
	TotalScanSize *int `json:"totalScanSize,omitempty"`

	// TotalScanTime Total estimated time the scan will take (seconds)
	TotalScanTime *int `json:"totalScanTime,omitempty"`
}

// ScanEstimations defines model for ScanEstimations.
type ScanEstimations struct {
	// Count Total ScanEstimations count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of ScanEstimations according to the given filters
	Items *[]ScanEstimation `json:"items,omitempty"`
}

// ScanExists defines model for ScanExists.
type ScanExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`

	// Scan Describes a multi-asset scheduled scan.
	Scan *Scan `json:"scan,omitempty"`
}

// ScanFamiliesConfig The configuration of the scanner families within a scan config
type ScanFamiliesConfig struct {
	Exploits          *ExploitsConfig          `json:"exploits,omitempty"`
	InfoFinder        *InfoFinderConfig        `json:"infoFinder,omitempty"`
	Malware           *MalwareConfig           `json:"malware,omitempty"`
	Misconfigurations *MisconfigurationsConfig `json:"misconfigurations,omitempty"`
	Rootkits          *RootkitsConfig          `json:"rootkits,omitempty"`
	Sbom              *SBOMConfig              `json:"sbom,omitempty"`
	Secrets           *SecretsConfig           `json:"secrets,omitempty"`
	Vulnerabilities   *VulnerabilitiesConfig   `json:"vulnerabilities,omitempty"`
}

// ScanFindingsSummary A summary of the scan findings.
type ScanFindingsSummary struct {
	TotalExploits          *int `json:"totalExploits,omitempty"`
	TotalInfoFinder        *int `json:"totalInfoFinder,omitempty"`
	TotalMalware           *int `json:"totalMalware,omitempty"`
	TotalMisconfigurations *int `json:"totalMisconfigurations,omitempty"`
	TotalPackages          *int `json:"totalPackages,omitempty"`
	TotalRootkits          *int `json:"totalRootkits,omitempty"`
	TotalSecrets           *int `json:"totalSecrets,omitempty"`

	// TotalVulnerabilities A summary of number of vulnerabilities found per severity.
	TotalVulnerabilities *VulnerabilityScanSummary `json:"totalVulnerabilities,omitempty"`
}

// ScanRelationship defines model for ScanRelationship.
type ScanRelationship struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *Annotations `json:"annotations,omitempty"`

	// AssetIDs List of asset IDs to be scanned
	AssetIDs          *[]string          `json:"assetIDs"`
	AssetScanTemplate *AssetScanTemplate `json:"assetScanTemplate,omitempty"`
	EndTime           *time.Time         `json:"endTime,omitempty"`
	Id                string             `json:"id"`

	// MaxParallelScanners The maximum number of asset scans that can be scheduled in parallel for this scan
	MaxParallelScanners *int    `json:"maxParallelScanners,omitempty"`
	Name                *string `json:"name,omitempty"`
	Revision            *int    `json:"revision,omitempty"`

	// ScanConfig Describes a relationship to a scan config which can be expanded.
	ScanConfig *ScanConfigRelationship `json:"scanConfig,omitempty"`

	// Scope The query used to limit the scope of this scan. It uses
	// the ODATA $filter query language to limit the collection of assets
	// that this scan will operate over. For example
	// `startswith(assetInfo.location, 'eu-west-2')` will limit this scan
	// to just assets in the eu-west-2 AWS region.
	Scope     *string    `json:"scope,omitempty"`
	StartTime *time.Time `json:"startTime,omitempty"`

	// State The lifecycle state of this scan.
	State *ScanRelationshipState `json:"state,omitempty"`

	// StateMessage Human-readable message indicating details about the last state transition.
	StateMessage *string `json:"stateMessage,omitempty"`

	// StateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
	StateReason *ScanRelationshipStateReason `json:"stateReason,omitempty"`

	// Summary A summary of the progress of a scan for informational purposes.
	Summary *ScanSummary `json:"summary,omitempty"`

	// TimeoutSeconds The maximum time in seconds that a scan started from this config
	// should run for before being automatically aborted.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// ScanRelationshipState The lifecycle state of this scan.
type ScanRelationshipState string

// ScanRelationshipStateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
type ScanRelationshipStateReason string

// ScanSummary defines model for ScanSummary.
type ScanSummary struct {
	JobsCompleted          *int `json:"jobsCompleted,omitempty"`
	JobsLeftToRun          *int `json:"jobsLeftToRun,omitempty"`
	TotalExploits          *int `json:"totalExploits,omitempty"`
	TotalInfoFinder        *int `json:"totalInfoFinder,omitempty"`
	TotalMalware           *int `json:"totalMalware,omitempty"`
	TotalMisconfigurations *int `json:"totalMisconfigurations,omitempty"`
	TotalPackages          *int `json:"totalPackages,omitempty"`
	TotalRootkits          *int `json:"totalRootkits,omitempty"`
	TotalSecrets           *int `json:"totalSecrets,omitempty"`

	// TotalVulnerabilities A summary of number of vulnerabilities found per severity.
	TotalVulnerabilities *VulnerabilityScanSummary `json:"totalVulnerabilities,omitempty"`
}

// ScanTemplate defines model for ScanTemplate.
type ScanTemplate struct {
	AssetScanTemplate *AssetScanTemplate `json:"assetScanTemplate,omitempty"`

	// MaxParallelScanners The maximum number of asset scans that can be scheduled in parallel for this scan
	MaxParallelScanners *int `json:"maxParallelScanners,omitempty"`

	// Scope The query used to limit the scope of this scan. It uses
	// the ODATA $filter query language to limit the collection of assets
	// that this scan will operate over. For example
	// `startswith(assetInfo.location, 'eu-west-2')` will limit this scan
	// to just assets in the eu-west-2 AWS region.
	Scope *string `json:"scope,omitempty"`

	// TimeoutSeconds The maximum time in seconds that a scan started from this config
	// should run for before being automatically aborted.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// ScanTemplateReadOnly defines model for ScanTemplateReadOnly.
type ScanTemplateReadOnly struct {
	AssetScanTemplate *AssetScanTemplate `json:"assetScanTemplate,omitempty"`

	// MaxParallelScanners The maximum number of asset scans that can be scheduled in parallel for this scan
	MaxParallelScanners *int `json:"maxParallelScanners,omitempty"`

	// Scope The query used to limit the scope of this scan. It uses
	// the ODATA $filter query language to limit the collection of assets
	// that this scan will operate over. For example
	// `startswith(assetInfo.location, 'eu-west-2')` will limit this scan
	// to just assets in the eu-west-2 AWS region.
	Scope *string `json:"scope,omitempty"`

	// TimeoutSeconds The maximum time in seconds that a scan started from this config
	// should run for before being automatically aborted.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// ScanType defines model for ScanType.
type ScanType string

// ScannerInstanceCreationConfig Configuration of scanner instance
type ScannerInstanceCreationConfig struct {
	MaxPrice         *string `json:"maxPrice,omitempty"`
	RetryMaxAttempts *int    `json:"retryMaxAttempts,omitempty"`
	UseSpotInstances bool    `json:"useSpotInstances"`
}

// ScannerMetadata defines model for ScannerMetadata.
type ScannerMetadata struct {
	ScannerName    *string         `json:"scannerName,omitempty"`
	ScannerSummary *ScannerSummary `json:"scannerSummary,omitempty"`
}

// ScannerStatus defines model for ScannerStatus.
type ScannerStatus struct {
	// LastTransitionTime Last date time when the status has changed.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message Human readable message.
	Message *string `json:"message,omitempty"`

	// Reason Machine readable reason for state transition.
	//
	// | State      | Reason            | Description                                 |
	// | ---------- | ----------------- | ------------------------------------------- |
	// | Pending    | Scheduled         | Scanner has been enabled in ScanConfig      |
	// | InProgress | Scanning          | Scanner is currently running                |
	// | Skipped    | NotScheduled      | Scanner hasn't been enabled in ScanConfig   |
	// | Failed     | Error             | Scanner finished with an error              |
	// | Done       | Success           | Scanner finished successfully               |
	Reason ScannerStatusReason `json:"reason"`

	// State Describes the state of a scanner on the asset.
	//
	// | State       | Description                                                              |
	// | ----------- | ------------------------------------------------------------------------ |
	// | Pending     | Scanner is pending and waits for state transition to InProgress state    |
	// | InProgress  | Scanning is being performed                                              |
	// | Skipped     | Scanner is **not** scheduled                                             |
	// | Failed      | Scanner has failed, check *reason* and *message* fields for the details  |
	// | Done        | Scanner has finished scanning with no errors                             |
	State ScannerStatusState `json:"state"`
}

// ScannerStatusReason Machine readable reason for state transition.
//
// | State      | Reason            | Description                                 |
// | ---------- | ----------------- | ------------------------------------------- |
// | Pending    | Scheduled         | Scanner has been enabled in ScanConfig      |
// | InProgress | Scanning          | Scanner is currently running                |
// | Skipped    | NotScheduled      | Scanner hasn't been enabled in ScanConfig   |
// | Failed     | Error             | Scanner finished with an error              |
// | Done       | Success           | Scanner finished successfully               |
type ScannerStatusReason string

// ScannerStatusState Describes the state of a scanner on the asset.
//
// | State       | Description                                                              |
// | ----------- | ------------------------------------------------------------------------ |
// | Pending     | Scanner is pending and waits for state transition to InProgress state    |
// | InProgress  | Scanning is being performed                                              |
// | Skipped     | Scanner is **not** scheduled                                             |
// | Failed      | Scanner has failed, check *reason* and *message* fields for the details  |
// | Done        | Scanner has finished scanning with no errors                             |
type ScannerStatusState string

// ScannerSummary defines model for ScannerSummary.
type ScannerSummary struct {
	DataRead           *string `json:"DataRead,omitempty"`
	DataScanned        *string `json:"DataScanned,omitempty"`
	EngineVersion      *string `json:"EngineVersion,omitempty"`
	InfectedFiles      *int    `json:"InfectedFiles,omitempty"`
	KnownViruses       *int    `json:"KnownViruses,omitempty"`
	ScannedDirectories *int    `json:"ScannedDirectories,omitempty"`
	ScannedFiles       *int    `json:"ScannedFiles,omitempty"`
	SuspectedFiles     *int    `json:"SuspectedFiles,omitempty"`
	TimeTaken          *string `json:"TimeTaken,omitempty"`
}

// Scans defines model for Scans.
type Scans struct {
	// Count Total scans count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of scans according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]Scan `json:"items,omitempty"`
}

// Secret defines model for Secret.
type Secret struct {
	Description *string `json:"description,omitempty"`
	EndColumn   *int    `json:"endColumn,omitempty"`
	EndLine     *int    `json:"endLine,omitempty"`

	// FilePath Name of the file containing the secret
	FilePath *string `json:"filePath,omitempty"`

	// Fingerprint Note: this is not unique
	Fingerprint *string `json:"fingerprint,omitempty"`
	StartColumn *int    `json:"startColumn,omitempty"`
	StartLine   *int    `json:"startLine,omitempty"`
}

// SecretFindingInfo defines model for SecretFindingInfo.
type SecretFindingInfo struct {
	Description *string `json:"description,omitempty"`
	EndColumn   *int    `json:"endColumn,omitempty"`
	EndLine     *int    `json:"endLine,omitempty"`

	// FilePath Name of the file containing the secret
	FilePath *string `json:"filePath,omitempty"`

	// Fingerprint Note: this is not unique
	Fingerprint *string `json:"fingerprint,omitempty"`
	ObjectType  string  `json:"objectType"`
	StartColumn *int    `json:"startColumn,omitempty"`
	StartLine   *int    `json:"startLine,omitempty"`
}

// SecretScan defines model for SecretScan.
type SecretScan struct {
	Secrets *[]Secret      `json:"secrets"`
	Status  *ScannerStatus `json:"status,omitempty"`
}

// SecretsConfig defines model for SecretsConfig.
type SecretsConfig struct {
	Enabled  *bool     `json:"enabled,omitempty"`
	Scanners *[]string `json:"scanners,omitempty"`
}

// SecurityGroup general cloud security group
type SecurityGroup struct {
	Id string `json:"id"`
}

// SuccessResponse An object that is returned in cases of success that returns nothing.
type SuccessResponse struct {
	Message *string `json:"message,omitempty"`
}

// Tag general cloud tag / label
type Tag struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// VMInfo defines model for VMInfo.
type VMInfo struct {
	Image            string         `json:"image"`
	InstanceID       string         `json:"instanceID"`
	InstanceProvider *CloudProvider `json:"instanceProvider,omitempty"`
	InstanceType     string         `json:"instanceType"`
	LaunchTime       time.Time      `json:"launchTime"`
	Location         string         `json:"location"`
	ObjectType       string         `json:"objectType"`
	Platform         string         `json:"platform"`

	// RootVolume Information about VM root volume
	RootVolume     RootVolume       `json:"rootVolume"`
	SecurityGroups *[]SecurityGroup `json:"securityGroups"`
	Tags           *[]Tag           `json:"tags"`
}

// VulnerabilitiesConfig defines model for VulnerabilitiesConfig.
type VulnerabilitiesConfig struct {
	Enabled  *bool     `json:"enabled,omitempty"`
	Scanners *[]string `json:"scanners,omitempty"`
}

// Vulnerability defines model for Vulnerability.
type Vulnerability struct {
	Cvss        *[]VulnerabilityCvss `json:"cvss"`
	Description *string              `json:"description,omitempty"`

	// Distro Distro provides information about a detected Linux distribution.
	Distro            *VulnerabilityDistro   `json:"distro,omitempty"`
	Fix               *VulnerabilityFix      `json:"fix,omitempty"`
	LayerId           *string                `json:"layerId,omitempty"`
	Links             *[]string              `json:"links"`
	Package           *Package               `json:"package,omitempty"`
	Path              *string                `json:"path,omitempty"`
	Severity          *VulnerabilitySeverity `json:"severity,omitempty"`
	VulnerabilityName *string                `json:"vulnerabilityName,omitempty"`
}

// VulnerabilityCvss defines model for VulnerabilityCvss.
type VulnerabilityCvss struct {
	Metrics *VulnerabilityCvssMetrics `json:"metrics,omitempty"`
	Vector  *string                   `json:"vector,omitempty"`
	Version *string                   `json:"version,omitempty"`
}

// VulnerabilityCvssMetrics defines model for VulnerabilityCvssMetrics.
type VulnerabilityCvssMetrics struct {
	BaseScore           *float32 `json:"baseScore,omitempty"`
	ExploitabilityScore *float32 `json:"exploitabilityScore,omitempty"`
	ImpactScore         *float32 `json:"impactScore,omitempty"`
}

// VulnerabilityDistro Distro provides information about a detected Linux distribution.
type VulnerabilityDistro struct {
	// IDLike the ID_LIKE field found within the /etc/os-release file
	IDLike *[]string `json:"IDLike"`

	// Name Name of the Linux distribution
	Name *string `json:"name,omitempty"`

	// Version Version of the Linux distribution (major or major.minor version)
	Version *string `json:"version,omitempty"`
}

// VulnerabilityFindingInfo defines model for VulnerabilityFindingInfo.
type VulnerabilityFindingInfo struct {
	Cvss        *[]VulnerabilityCvss `json:"cvss"`
	Description *string              `json:"description,omitempty"`

	// Distro Distro provides information about a detected Linux distribution.
	Distro            *VulnerabilityDistro   `json:"distro,omitempty"`
	Fix               *VulnerabilityFix      `json:"fix,omitempty"`
	LayerId           *string                `json:"layerId,omitempty"`
	Links             *[]string              `json:"links"`
	ObjectType        string                 `json:"objectType"`
	Package           *Package               `json:"package,omitempty"`
	Path              *string                `json:"path,omitempty"`
	Severity          *VulnerabilitySeverity `json:"severity,omitempty"`
	VulnerabilityName *string                `json:"vulnerabilityName,omitempty"`
}

// VulnerabilityFix defines model for VulnerabilityFix.
type VulnerabilityFix struct {
	State    *string   `json:"state,omitempty"`
	Versions *[]string `json:"versions"`
}

// VulnerabilityScan defines model for VulnerabilityScan.
type VulnerabilityScan struct {
	Status          *ScannerStatus   `json:"status,omitempty"`
	Vulnerabilities *[]Vulnerability `json:"vulnerabilities"`
}

// VulnerabilityScanSummary A summary of number of vulnerabilities found per severity.
type VulnerabilityScanSummary struct {
	TotalCriticalVulnerabilities   *int `json:"totalCriticalVulnerabilities,omitempty"`
	TotalHighVulnerabilities       *int `json:"totalHighVulnerabilities,omitempty"`
	TotalLowVulnerabilities        *int `json:"totalLowVulnerabilities,omitempty"`
	TotalMediumVulnerabilities     *int `json:"totalMediumVulnerabilities,omitempty"`
	TotalNegligibleVulnerabilities *int `json:"totalNegligibleVulnerabilities,omitempty"`
}

// VulnerabilitySeverity defines model for VulnerabilitySeverity.
type VulnerabilitySeverity string

// AssetID defines model for assetID.
type AssetID = string

// AssetScanEstimationID defines model for assetScanEstimationID.
type AssetScanEstimationID = string

// AssetScanID defines model for assetScanID.
type AssetScanID = string

// FindingID defines model for findingID.
type FindingID = string

// Ifmatch defines model for ifmatch.
type Ifmatch = int

// OdataCount defines model for odataCount.
type OdataCount = bool

// OdataExpand defines model for odataExpand.
type OdataExpand = string

// OdataFilter defines model for odataFilter.
type OdataFilter = string

// OrderBy defines model for odataOrderBy.
type OrderBy = string

// OdataSelect defines model for odataSelect.
type OdataSelect = string

// OdataSkip defines model for odataSkip.
type OdataSkip = int

// OdataTop defines model for odataTop.
type OdataTop = int

// ProviderID defines model for providerID.
type ProviderID = string

// ScanConfigID defines model for scanConfigID.
type ScanConfigID = string

// ScanEstimationID defines model for scanEstimationID.
type ScanEstimationID = string

// ScanID defines model for scanID.
type ScanID = string

// Success An object that is returned in cases of success that returns nothing.
type Success = SuccessResponse

// UnknownError An object that is returned in all cases of failures.
type UnknownError = ApiResponse

// GetAssetScanEstimationsParams defines parameters for GetAssetScanEstimations.
type GetAssetScanEstimationsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetAssetScanEstimationsAssetScanEstimationIDParams defines parameters for GetAssetScanEstimationsAssetScanEstimationID.
type GetAssetScanEstimationsAssetScanEstimationIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchAssetScanEstimationsAssetScanEstimationIDParams defines parameters for PatchAssetScanEstimationsAssetScanEstimationID.
type PatchAssetScanEstimationsAssetScanEstimationIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutAssetScanEstimationsAssetScanEstimationIDParams defines parameters for PutAssetScanEstimationsAssetScanEstimationID.
type PutAssetScanEstimationsAssetScanEstimationIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetAssetScansParams defines parameters for GetAssetScans.
type GetAssetScansParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetAssetScansAssetScanIDParams defines parameters for GetAssetScansAssetScanID.
type GetAssetScansAssetScanIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchAssetScansAssetScanIDParams defines parameters for PatchAssetScansAssetScanID.
type PatchAssetScansAssetScanIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutAssetScansAssetScanIDParams defines parameters for PutAssetScansAssetScanID.
type PutAssetScansAssetScanIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetAssetsParams defines parameters for GetAssets.
type GetAssetsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetAssetsAssetIDParams defines parameters for GetAssetsAssetID.
type GetAssetsAssetIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchAssetsAssetIDParams defines parameters for PatchAssetsAssetID.
type PatchAssetsAssetIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutAssetsAssetIDParams defines parameters for PutAssetsAssetID.
type PutAssetsAssetIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetFindingsParams defines parameters for GetFindings.
type GetFindingsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetFindingsFindingIDParams defines parameters for GetFindingsFindingID.
type GetFindingsFindingIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// GetProvidersParams defines parameters for GetProviders.
type GetProvidersParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetProvidersProviderIDParams defines parameters for GetProvidersProviderID.
type GetProvidersProviderIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchProvidersProviderIDParams defines parameters for PatchProvidersProviderID.
type PatchProvidersProviderIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutProvidersProviderIDParams defines parameters for PutProvidersProviderID.
type PutProvidersProviderIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetScanConfigsParams defines parameters for GetScanConfigs.
type GetScanConfigsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetScanConfigsScanConfigIDParams defines parameters for GetScanConfigsScanConfigID.
type GetScanConfigsScanConfigIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchScanConfigsScanConfigIDParams defines parameters for PatchScanConfigsScanConfigID.
type PatchScanConfigsScanConfigIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutScanConfigsScanConfigIDParams defines parameters for PutScanConfigsScanConfigID.
type PutScanConfigsScanConfigIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetScanEstimationsParams defines parameters for GetScanEstimations.
type GetScanEstimationsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetScanEstimationsScanEstimationIDParams defines parameters for GetScanEstimationsScanEstimationID.
type GetScanEstimationsScanEstimationIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchScanEstimationsScanEstimationIDParams defines parameters for PatchScanEstimationsScanEstimationID.
type PatchScanEstimationsScanEstimationIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutScanEstimationsScanEstimationIDParams defines parameters for PutScanEstimationsScanEstimationID.
type PutScanEstimationsScanEstimationIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetScansParams defines parameters for GetScans.
type GetScansParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetScansScanIDParams defines parameters for GetScansScanID.
type GetScansScanIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchScansScanIDParams defines parameters for PatchScansScanID.
type PatchScansScanIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutScansScanIDParams defines parameters for PutScansScanID.
type PutScansScanIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PostAssetScanEstimationsJSONRequestBody defines body for PostAssetScanEstimations for application/json ContentType.
type PostAssetScanEstimationsJSONRequestBody = AssetScanEstimation

// PatchAssetScanEstimationsAssetScanEstimationIDJSONRequestBody defines body for PatchAssetScanEstimationsAssetScanEstimationID for application/json ContentType.
type PatchAssetScanEstimationsAssetScanEstimationIDJSONRequestBody = AssetScanEstimation

// PutAssetScanEstimationsAssetScanEstimationIDJSONRequestBody defines body for PutAssetScanEstimationsAssetScanEstimationID for application/json ContentType.
type PutAssetScanEstimationsAssetScanEstimationIDJSONRequestBody = AssetScanEstimation

// PostAssetScansJSONRequestBody defines body for PostAssetScans for application/json ContentType.
type PostAssetScansJSONRequestBody = AssetScan

// PatchAssetScansAssetScanIDJSONRequestBody defines body for PatchAssetScansAssetScanID for application/json ContentType.
type PatchAssetScansAssetScanIDJSONRequestBody = AssetScan

// PutAssetScansAssetScanIDJSONRequestBody defines body for PutAssetScansAssetScanID for application/json ContentType.
type PutAssetScansAssetScanIDJSONRequestBody = AssetScan

// PostAssetsJSONRequestBody defines body for PostAssets for application/json ContentType.
type PostAssetsJSONRequestBody = Asset

// PatchAssetsAssetIDJSONRequestBody defines body for PatchAssetsAssetID for application/json ContentType.
type PatchAssetsAssetIDJSONRequestBody = Asset

// PutAssetsAssetIDJSONRequestBody defines body for PutAssetsAssetID for application/json ContentType.
type PutAssetsAssetIDJSONRequestBody = Asset

// PostFindingsJSONRequestBody defines body for PostFindings for application/json ContentType.
type PostFindingsJSONRequestBody = Finding

// PatchFindingsFindingIDJSONRequestBody defines body for PatchFindingsFindingID for application/json ContentType.
type PatchFindingsFindingIDJSONRequestBody = Finding

// PutFindingsFindingIDJSONRequestBody defines body for PutFindingsFindingID for application/json ContentType.
type PutFindingsFindingIDJSONRequestBody = Finding

// PostProvidersJSONRequestBody defines body for PostProviders for application/json ContentType.
type PostProvidersJSONRequestBody = Provider

// PatchProvidersProviderIDJSONRequestBody defines body for PatchProvidersProviderID for application/json ContentType.
type PatchProvidersProviderIDJSONRequestBody = Provider

// PutProvidersProviderIDJSONRequestBody defines body for PutProvidersProviderID for application/json ContentType.
type PutProvidersProviderIDJSONRequestBody = Provider

// PostScanConfigsJSONRequestBody defines body for PostScanConfigs for application/json ContentType.
type PostScanConfigsJSONRequestBody = ScanConfig

// PatchScanConfigsScanConfigIDJSONRequestBody defines body for PatchScanConfigsScanConfigID for application/json ContentType.
type PatchScanConfigsScanConfigIDJSONRequestBody = ScanConfig

// PutScanConfigsScanConfigIDJSONRequestBody defines body for PutScanConfigsScanConfigID for application/json ContentType.
type PutScanConfigsScanConfigIDJSONRequestBody = ScanConfig

// PostScanEstimationsJSONRequestBody defines body for PostScanEstimations for application/json ContentType.
type PostScanEstimationsJSONRequestBody = ScanEstimation

// PatchScanEstimationsScanEstimationIDJSONRequestBody defines body for PatchScanEstimationsScanEstimationID for application/json ContentType.
type PatchScanEstimationsScanEstimationIDJSONRequestBody = ScanEstimation

// PutScanEstimationsScanEstimationIDJSONRequestBody defines body for PutScanEstimationsScanEstimationID for application/json ContentType.
type PutScanEstimationsScanEstimationIDJSONRequestBody = ScanEstimation

// PostScansJSONRequestBody defines body for PostScans for application/json ContentType.
type PostScansJSONRequestBody = Scan

// PatchScansScanIDJSONRequestBody defines body for PatchScansScanID for application/json ContentType.
type PatchScansScanIDJSONRequestBody = Scan

// PutScansScanIDJSONRequestBody defines body for PutScansScanID for application/json ContentType.
type PutScansScanIDJSONRequestBody = Scan

// AsVMInfo returns the union data inside the AssetType as a VMInfo
func (t AssetType) AsVMInfo() (VMInfo, error) {
	var body VMInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMInfo overwrites any union data inside the AssetType as the provided VMInfo
func (t *AssetType) FromVMInfo(v VMInfo) error {
	v.ObjectType = "VMInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMInfo performs a merge with any union data inside the AssetType, using the provided VMInfo
func (t *AssetType) MergeVMInfo(v VMInfo) error {
	v.ObjectType = "VMInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsPodInfo returns the union data inside the AssetType as a PodInfo
func (t AssetType) AsPodInfo() (PodInfo, error) {
	var body PodInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPodInfo overwrites any union data inside the AssetType as the provided PodInfo
func (t *AssetType) FromPodInfo(v PodInfo) error {
	v.ObjectType = "PodInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePodInfo performs a merge with any union data inside the AssetType, using the provided PodInfo
func (t *AssetType) MergePodInfo(v PodInfo) error {
	v.ObjectType = "PodInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDirInfo returns the union data inside the AssetType as a DirInfo
func (t AssetType) AsDirInfo() (DirInfo, error) {
	var body DirInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDirInfo overwrites any union data inside the AssetType as the provided DirInfo
func (t *AssetType) FromDirInfo(v DirInfo) error {
	v.ObjectType = "DirInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDirInfo performs a merge with any union data inside the AssetType, using the provided DirInfo
func (t *AssetType) MergeDirInfo(v DirInfo) error {
	v.ObjectType = "DirInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerImageInfo returns the union data inside the AssetType as a ContainerImageInfo
func (t AssetType) AsContainerImageInfo() (ContainerImageInfo, error) {
	var body ContainerImageInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerImageInfo overwrites any union data inside the AssetType as the provided ContainerImageInfo
func (t *AssetType) FromContainerImageInfo(v ContainerImageInfo) error {
	v.ObjectType = "ContainerImageInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerImageInfo performs a merge with any union data inside the AssetType, using the provided ContainerImageInfo
func (t *AssetType) MergeContainerImageInfo(v ContainerImageInfo) error {
	v.ObjectType = "ContainerImageInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerInfo returns the union data inside the AssetType as a ContainerInfo
func (t AssetType) AsContainerInfo() (ContainerInfo, error) {
	var body ContainerInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerInfo overwrites any union data inside the AssetType as the provided ContainerInfo
func (t *AssetType) FromContainerInfo(v ContainerInfo) error {
	v.ObjectType = "ContainerInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerInfo performs a merge with any union data inside the AssetType, using the provided ContainerInfo
func (t *AssetType) MergeContainerInfo(v ContainerInfo) error {
	v.ObjectType = "ContainerInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AssetType) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"objectType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AssetType) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ContainerImageInfo":
		return t.AsContainerImageInfo()
	case "ContainerInfo":
		return t.AsContainerInfo()
	case "DirInfo":
		return t.AsDirInfo()
	case "PodInfo":
		return t.AsPodInfo()
	case "VMInfo":
		return t.AsVMInfo()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AssetType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AssetType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPackageFindingInfo returns the union data inside the Finding_FindingInfo as a PackageFindingInfo
func (t Finding_FindingInfo) AsPackageFindingInfo() (PackageFindingInfo, error) {
	var body PackageFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided PackageFindingInfo
func (t *Finding_FindingInfo) FromPackageFindingInfo(v PackageFindingInfo) error {
	v.ObjectType = "Package"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided PackageFindingInfo
func (t *Finding_FindingInfo) MergePackageFindingInfo(v PackageFindingInfo) error {
	v.ObjectType = "Package"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnerabilityFindingInfo returns the union data inside the Finding_FindingInfo as a VulnerabilityFindingInfo
func (t Finding_FindingInfo) AsVulnerabilityFindingInfo() (VulnerabilityFindingInfo, error) {
	var body VulnerabilityFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnerabilityFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided VulnerabilityFindingInfo
func (t *Finding_FindingInfo) FromVulnerabilityFindingInfo(v VulnerabilityFindingInfo) error {
	v.ObjectType = "Vulnerability"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnerabilityFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided VulnerabilityFindingInfo
func (t *Finding_FindingInfo) MergeVulnerabilityFindingInfo(v VulnerabilityFindingInfo) error {
	v.ObjectType = "Vulnerability"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMalwareFindingInfo returns the union data inside the Finding_FindingInfo as a MalwareFindingInfo
func (t Finding_FindingInfo) AsMalwareFindingInfo() (MalwareFindingInfo, error) {
	var body MalwareFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMalwareFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided MalwareFindingInfo
func (t *Finding_FindingInfo) FromMalwareFindingInfo(v MalwareFindingInfo) error {
	v.ObjectType = "Malware"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMalwareFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided MalwareFindingInfo
func (t *Finding_FindingInfo) MergeMalwareFindingInfo(v MalwareFindingInfo) error {
	v.ObjectType = "Malware"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecretFindingInfo returns the union data inside the Finding_FindingInfo as a SecretFindingInfo
func (t Finding_FindingInfo) AsSecretFindingInfo() (SecretFindingInfo, error) {
	var body SecretFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecretFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided SecretFindingInfo
func (t *Finding_FindingInfo) FromSecretFindingInfo(v SecretFindingInfo) error {
	v.ObjectType = "Secret"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecretFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided SecretFindingInfo
func (t *Finding_FindingInfo) MergeSecretFindingInfo(v SecretFindingInfo) error {
	v.ObjectType = "Secret"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMisconfigurationFindingInfo returns the union data inside the Finding_FindingInfo as a MisconfigurationFindingInfo
func (t Finding_FindingInfo) AsMisconfigurationFindingInfo() (MisconfigurationFindingInfo, error) {
	var body MisconfigurationFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMisconfigurationFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided MisconfigurationFindingInfo
func (t *Finding_FindingInfo) FromMisconfigurationFindingInfo(v MisconfigurationFindingInfo) error {
	v.ObjectType = "Misconfiguration"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMisconfigurationFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided MisconfigurationFindingInfo
func (t *Finding_FindingInfo) MergeMisconfigurationFindingInfo(v MisconfigurationFindingInfo) error {
	v.ObjectType = "Misconfiguration"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRootkitFindingInfo returns the union data inside the Finding_FindingInfo as a RootkitFindingInfo
func (t Finding_FindingInfo) AsRootkitFindingInfo() (RootkitFindingInfo, error) {
	var body RootkitFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRootkitFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided RootkitFindingInfo
func (t *Finding_FindingInfo) FromRootkitFindingInfo(v RootkitFindingInfo) error {
	v.ObjectType = "Rootkit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRootkitFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided RootkitFindingInfo
func (t *Finding_FindingInfo) MergeRootkitFindingInfo(v RootkitFindingInfo) error {
	v.ObjectType = "Rootkit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsExploitFindingInfo returns the union data inside the Finding_FindingInfo as a ExploitFindingInfo
func (t Finding_FindingInfo) AsExploitFindingInfo() (ExploitFindingInfo, error) {
	var body ExploitFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExploitFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided ExploitFindingInfo
func (t *Finding_FindingInfo) FromExploitFindingInfo(v ExploitFindingInfo) error {
	v.ObjectType = "Exploit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExploitFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided ExploitFindingInfo
func (t *Finding_FindingInfo) MergeExploitFindingInfo(v ExploitFindingInfo) error {
	v.ObjectType = "Exploit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsInfoFinderFindingInfo returns the union data inside the Finding_FindingInfo as a InfoFinderFindingInfo
func (t Finding_FindingInfo) AsInfoFinderFindingInfo() (InfoFinderFindingInfo, error) {
	var body InfoFinderFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInfoFinderFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided InfoFinderFindingInfo
func (t *Finding_FindingInfo) FromInfoFinderFindingInfo(v InfoFinderFindingInfo) error {
	v.ObjectType = "InfoFinder"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInfoFinderFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided InfoFinderFindingInfo
func (t *Finding_FindingInfo) MergeInfoFinderFindingInfo(v InfoFinderFindingInfo) error {
	v.ObjectType = "InfoFinder"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Finding_FindingInfo) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"objectType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Finding_FindingInfo) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "Exploit":
		return t.AsExploitFindingInfo()
	case "InfoFinder":
		return t.AsInfoFinderFindingInfo()
	case "Malware":
		return t.AsMalwareFindingInfo()
	case "Misconfiguration":
		return t.AsMisconfigurationFindingInfo()
	case "Package":
		return t.AsPackageFindingInfo()
	case "Rootkit":
		return t.AsRootkitFindingInfo()
	case "Secret":
		return t.AsSecretFindingInfo()
	case "Vulnerability":
		return t.AsVulnerabilityFindingInfo()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Finding_FindingInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Finding_FindingInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
