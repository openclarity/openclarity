// Package models provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package models

import (
	"encoding/json"
	"errors"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for AssetScanStateState.
const (
	AssetScanStateStateAborted     AssetScanStateState = "Aborted"
	AssetScanStateStateDone        AssetScanStateState = "Done"
	AssetScanStateStateInProgress  AssetScanStateState = "InProgress"
	AssetScanStateStateNotScanned  AssetScanStateState = "NotScanned"
	AssetScanStateStatePending     AssetScanStateState = "Pending"
	AssetScanStateStateReadyToScan AssetScanStateState = "ReadyToScan"
	AssetScanStateStateScheduled   AssetScanStateState = "Scheduled"
)

// Defines values for CloudProvider.
const (
	AWS   CloudProvider = "AWS"
	Azure CloudProvider = "Azure"
)

// Defines values for MisconfigurationSeverity.
const (
	MisconfigurationHighSeverity   MisconfigurationSeverity = "MisconfigurationHighSeverity"
	MisconfigurationLowSeverity    MisconfigurationSeverity = "MisconfigurationLowSeverity"
	MisconfigurationMediumSeverity MisconfigurationSeverity = "MisconfigurationMediumSeverity"
)

// Defines values for ResourceCleanupState.
const (
	ResourceCleanupStateDone    ResourceCleanupState = "Done"
	ResourceCleanupStateFailed  ResourceCleanupState = "Failed"
	ResourceCleanupStatePending ResourceCleanupState = "Pending"
	ResourceCleanupStateSkipped ResourceCleanupState = "Skipped"
)

// Defines values for RootkitType.
const (
	APPLICATION RootkitType = "APPLICATION"
	FIRMWARE    RootkitType = "FIRMWARE"
	KERNEL      RootkitType = "KERNEL"
	MEMORY      RootkitType = "MEMORY"
	UNKNOWN     RootkitType = "UNKNOWN"
)

// Defines values for ScanState.
const (
	ScanStateAborted    ScanState = "Aborted"
	ScanStateDiscovered ScanState = "Discovered"
	ScanStateDone       ScanState = "Done"
	ScanStateFailed     ScanState = "Failed"
	ScanStateInProgress ScanState = "InProgress"
	ScanStatePending    ScanState = "Pending"
)

// Defines values for ScanStateReason.
const (
	ScanStateReasonAborted                    ScanStateReason = "Aborted"
	ScanStateReasonDiscoveryFailed            ScanStateReason = "DiscoveryFailed"
	ScanStateReasonNothingToScan              ScanStateReason = "NothingToScan"
	ScanStateReasonOneOrMoreAssetFailedToScan ScanStateReason = "OneOrMoreAssetFailedToScan"
	ScanStateReasonSuccess                    ScanStateReason = "Success"
	ScanStateReasonTimedOut                   ScanStateReason = "TimedOut"
	ScanStateReasonUnexpected                 ScanStateReason = "Unexpected"
)

// Defines values for ScanRelationshipState.
const (
	ScanRelationshipStateAborted    ScanRelationshipState = "Aborted"
	ScanRelationshipStateDiscovered ScanRelationshipState = "Discovered"
	ScanRelationshipStateDone       ScanRelationshipState = "Done"
	ScanRelationshipStateFailed     ScanRelationshipState = "Failed"
	ScanRelationshipStateInProgress ScanRelationshipState = "InProgress"
	ScanRelationshipStatePending    ScanRelationshipState = "Pending"
)

// Defines values for ScanRelationshipStateReason.
const (
	ScanRelationshipStateReasonAborted                    ScanRelationshipStateReason = "Aborted"
	ScanRelationshipStateReasonDiscoveryFailed            ScanRelationshipStateReason = "DiscoveryFailed"
	ScanRelationshipStateReasonNothingToScan              ScanRelationshipStateReason = "NothingToScan"
	ScanRelationshipStateReasonOneOrMoreAssetFailedToScan ScanRelationshipStateReason = "OneOrMoreAssetFailedToScan"
	ScanRelationshipStateReasonSuccess                    ScanRelationshipStateReason = "Success"
	ScanRelationshipStateReasonTimedOut                   ScanRelationshipStateReason = "TimedOut"
	ScanRelationshipStateReasonUnexpected                 ScanRelationshipStateReason = "Unexpected"
)

// Defines values for ScanType.
const (
	EXPLOIT          ScanType = "EXPLOIT"
	MALWARE          ScanType = "MALWARE"
	MISCONFIGURATION ScanType = "MISCONFIGURATION"
	ROOTKIT          ScanType = "ROOTKIT"
	SBOM             ScanType = "SBOM"
	SECRET           ScanType = "SECRET"
	VULNERABILITY    ScanType = "VULNERABILITY"
)

// Defines values for VulnerabilitySeverity.
const (
	CRITICAL   VulnerabilitySeverity = "CRITICAL"
	HIGH       VulnerabilitySeverity = "HIGH"
	LOW        VulnerabilitySeverity = "LOW"
	MEDIUM     VulnerabilitySeverity = "MEDIUM"
	NEGLIGIBLE VulnerabilitySeverity = "NEGLIGIBLE"
)

// ApiResponse An object that is returned in all cases of failures.
type ApiResponse struct {
	Message *string `json:"message,omitempty"`
}

// Asset Describes an asset object.
type Asset struct {
	AssetInfo *AssetType `json:"assetInfo,omitempty"`
	Id        *string    `json:"id,omitempty"`
	LastSeen  *time.Time `json:"lastSeen,omitempty"`
	Revision  *int       `json:"revision,omitempty"`

	// ScansCount Total number of scans that have ever run for this asset
	ScansCount *int `json:"scansCount,omitempty"`

	// Summary A summary of the scan findings.
	Summary    *ScanFindingsSummary `json:"summary,omitempty"`
	Terminated *time.Time           `json:"terminated,omitempty"`
}

// AssetCommon defines model for AssetCommon.
type AssetCommon = map[string]interface{}

// AssetExists defines model for AssetExists.
type AssetExists struct {
	// Asset Describes an asset object.
	Asset *Asset `json:"asset,omitempty"`

	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`
}

// AssetRelationship Describes a relationship to an asset which can be expanded.
type AssetRelationship struct {
	AssetInfo *AssetType `json:"assetInfo,omitempty"`
	Id        string     `json:"id"`
	Revision  *int       `json:"revision,omitempty"`

	// ScansCount Total number of scans that have ever run for this asset
	ScansCount *int `json:"scansCount,omitempty"`

	// Summary A summary of the scan findings.
	Summary *ScanFindingsSummary `json:"summary,omitempty"`
}

// AssetScan defines model for AssetScan.
type AssetScan struct {
	// Asset Describes a relationship to an asset which can be expanded.
	Asset             *AssetRelationship    `json:"asset,omitempty"`
	Exploits          *ExploitScan          `json:"exploits,omitempty"`
	FindingsProcessed *bool                 `json:"findingsProcessed,omitempty"`
	Id                *string               `json:"id,omitempty"`
	Malware           *MalwareScan          `json:"malware,omitempty"`
	Misconfigurations *MisconfigurationScan `json:"misconfigurations,omitempty"`
	ResourceCleanup   *ResourceCleanupState `json:"resourceCleanup,omitempty"`
	Revision          *int                  `json:"revision,omitempty"`
	Rootkits          *RootkitScan          `json:"rootkits,omitempty"`
	Sboms             *SbomScan             `json:"sboms,omitempty"`

	// Scan Describes an expandable relationship to Scan object
	Scan    *ScanRelationship `json:"scan,omitempty"`
	Secrets *SecretScan       `json:"secrets,omitempty"`
	Status  *AssetScanStatus  `json:"status,omitempty"`

	// Summary A summary of the scan findings.
	Summary         *ScanFindingsSummary `json:"summary,omitempty"`
	Vulnerabilities *VulnerabilityScan   `json:"vulnerabilities,omitempty"`
}

// AssetScanExists defines model for AssetScanExists.
type AssetScanExists struct {
	AssetScan *AssetScan `json:"assetScan,omitempty"`

	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`
}

// AssetScanState defines model for AssetScanState.
type AssetScanState struct {
	Errors             *[]string            `json:"errors"`
	LastTransitionTime *time.Time           `json:"lastTransitionTime,omitempty"`
	State              *AssetScanStateState `json:"state,omitempty"`
}

// AssetScanStateState defines model for AssetScanState.State.
type AssetScanStateState string

// AssetScanStatus defines model for AssetScanStatus.
type AssetScanStatus struct {
	Exploits          *AssetScanState `json:"exploits,omitempty"`
	General           *AssetScanState `json:"general,omitempty"`
	Malware           *AssetScanState `json:"malware,omitempty"`
	Misconfigurations *AssetScanState `json:"misconfigurations,omitempty"`
	Rootkits          *AssetScanState `json:"rootkits,omitempty"`
	Sbom              *AssetScanState `json:"sbom,omitempty"`
	Secrets           *AssetScanState `json:"secrets,omitempty"`
	Vulnerabilities   *AssetScanState `json:"vulnerabilities,omitempty"`
}

// AssetScans defines model for AssetScans.
type AssetScans struct {
	// Count Total asset scans count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of asset scans according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]AssetScan `json:"items,omitempty"`
}

// AssetType defines model for AssetType.
type AssetType struct {
	union json.RawMessage
}

// Assets defines model for Assets.
type Assets struct {
	// Count Total assets count according the given filters
	Count *int `json:"count,omitempty"`

	// Items List of assets in the given filters and page. List length must be lower or equal to pageSize.
	Items *[]Asset `json:"items,omitempty"`
}

// CloudProvider defines model for CloudProvider.
type CloudProvider string

// DirInfo defines model for DirInfo.
type DirInfo struct {
	DirName    *string `json:"dirName,omitempty"`
	Location   *string `json:"location,omitempty"`
	ObjectType string  `json:"objectType"`
}

// Exploit defines model for Exploit.
type Exploit struct {
	CveID       *string   `json:"cveID,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	SourceDB    *string   `json:"sourceDB,omitempty"`
	Title       *string   `json:"title,omitempty"`
	Urls        *[]string `json:"urls"`
}

// ExploitFindingInfo defines model for ExploitFindingInfo.
type ExploitFindingInfo struct {
	CveID       *string   `json:"cveID,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	ObjectType  string    `json:"objectType"`
	SourceDB    *string   `json:"sourceDB,omitempty"`
	Title       *string   `json:"title,omitempty"`
	Urls        *[]string `json:"urls"`
}

// ExploitScan defines model for ExploitScan.
type ExploitScan struct {
	Exploits *[]Exploit `json:"exploits"`
}

// ExploitsConfig defines model for ExploitsConfig.
type ExploitsConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// Finding defines model for Finding.
type Finding struct {
	// Asset Describes a relationship to an asset which can be expanded.
	Asset       *AssetRelationship   `json:"asset,omitempty"`
	FindingInfo *Finding_FindingInfo `json:"findingInfo,omitempty"`

	// FoundOn When this finding was discovered by a scan
	FoundOn *time.Time `json:"foundOn,omitempty"`
	Id      *string    `json:"id,omitempty"`

	// InvalidatedOn When this finding was invalidated by a newer scan
	InvalidatedOn *time.Time `json:"invalidatedOn,omitempty"`

	// Scan Describes an expandable relationship to Scan object
	Scan *ScanRelationship `json:"scan,omitempty"`
}

// Finding_FindingInfo defines model for Finding.FindingInfo.
type Finding_FindingInfo struct {
	union json.RawMessage
}

// FindingExists defines model for FindingExists.
type FindingExists struct {
	Finding *Finding `json:"finding,omitempty"`

	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`
}

// Findings defines model for Findings.
type Findings struct {
	// Count Total findings count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of findings according to the given filters
	Items *[]Finding `json:"items,omitempty"`
}

// Malware defines model for Malware.
type Malware struct {
	MalwareName *string      `json:"malwareName,omitempty"`
	MalwareType *MalwareType `json:"malwareType,omitempty"`

	// Path Path of the file that contains malware
	Path *string `json:"path,omitempty"`
}

// MalwareConfig defines model for MalwareConfig.
type MalwareConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// MalwareFindingInfo defines model for MalwareFindingInfo.
type MalwareFindingInfo struct {
	MalwareName *string      `json:"malwareName,omitempty"`
	MalwareType *MalwareType `json:"malwareType,omitempty"`
	ObjectType  string       `json:"objectType"`

	// Path Path of the file that contains malware
	Path *string `json:"path,omitempty"`
}

// MalwareScan defines model for MalwareScan.
type MalwareScan struct {
	Malware  *[]Malware         `json:"malware"`
	Metadata *[]ScannerMetadata `json:"metadata"`
}

// MalwareType defines model for MalwareType.
type MalwareType = string

// Misconfiguration defines model for Misconfiguration.
type Misconfiguration struct {
	Message         *string                   `json:"message,omitempty"`
	Remediation     *string                   `json:"remediation,omitempty"`
	ScannedPath     *string                   `json:"scannedPath,omitempty"`
	ScannerName     *string                   `json:"scannerName,omitempty"`
	Severity        *MisconfigurationSeverity `json:"severity,omitempty"`
	TestCategory    *string                   `json:"testCategory,omitempty"`
	TestDescription *string                   `json:"testDescription,omitempty"`
	TestID          *string                   `json:"testID,omitempty"`
}

// MisconfigurationFindingInfo defines model for MisconfigurationFindingInfo.
type MisconfigurationFindingInfo struct {
	Message         *string                   `json:"message,omitempty"`
	ObjectType      string                    `json:"objectType"`
	Remediation     *string                   `json:"remediation,omitempty"`
	ScannedPath     *string                   `json:"scannedPath,omitempty"`
	ScannerName     *string                   `json:"scannerName,omitempty"`
	Severity        *MisconfigurationSeverity `json:"severity,omitempty"`
	TestCategory    *string                   `json:"testCategory,omitempty"`
	TestDescription *string                   `json:"testDescription,omitempty"`
	TestID          *string                   `json:"testID,omitempty"`
}

// MisconfigurationScan defines model for MisconfigurationScan.
type MisconfigurationScan struct {
	Misconfigurations *[]Misconfiguration `json:"misconfigurations"`
	Scanners          *[]string           `json:"scanners"`
}

// MisconfigurationSeverity defines model for MisconfigurationSeverity.
type MisconfigurationSeverity string

// MisconfigurationsConfig defines model for MisconfigurationsConfig.
type MisconfigurationsConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// Package defines model for Package.
type Package struct {
	Cpes     *[]string `json:"cpes"`
	Language *string   `json:"language,omitempty"`
	Licenses *[]string `json:"licenses"`
	Name     *string   `json:"name,omitempty"`
	Purl     *string   `json:"purl,omitempty"`
	Type     *string   `json:"type,omitempty"`
	Version  *string   `json:"version,omitempty"`
}

// PackageFindingInfo defines model for PackageFindingInfo.
type PackageFindingInfo struct {
	Cpes       *[]string `json:"cpes"`
	Language   *string   `json:"language,omitempty"`
	Licenses   *[]string `json:"licenses"`
	Name       *string   `json:"name,omitempty"`
	ObjectType string    `json:"objectType"`
	Purl       *string   `json:"purl,omitempty"`
	Type       *string   `json:"type,omitempty"`
	Version    *string   `json:"version,omitempty"`
}

// PodInfo defines model for PodInfo.
type PodInfo struct {
	Location   *string `json:"location,omitempty"`
	ObjectType string  `json:"objectType"`
	PodName    *string `json:"podName,omitempty"`
}

// ResourceCleanupState defines model for ResourceCleanupState.
type ResourceCleanupState string

// Rootkit defines model for Rootkit.
type Rootkit struct {
	Message     *string      `json:"message,omitempty"`
	RootkitName *string      `json:"rootkitName,omitempty"`
	RootkitType *RootkitType `json:"rootkitType,omitempty"`
}

// RootkitFindingInfo defines model for RootkitFindingInfo.
type RootkitFindingInfo struct {
	Message     *string      `json:"message,omitempty"`
	ObjectType  string       `json:"objectType"`
	RootkitName *string      `json:"rootkitName,omitempty"`
	RootkitType *RootkitType `json:"rootkitType,omitempty"`
}

// RootkitScan defines model for RootkitScan.
type RootkitScan struct {
	Rootkits *[]Rootkit `json:"rootkits"`
}

// RootkitType defines model for RootkitType.
type RootkitType string

// RootkitsConfig defines model for RootkitsConfig.
type RootkitsConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// RuntimeScheduleScanConfig Runtime schedule scan configuration. If only operationTime is set, it will be a single scan scheduled for the operationTime. If only cronLine is set, the current time will be the "from time" to start the scheduling according to the cronLine. If both operationTime and cronLine are set, the first scan will run at operationTime and the operationTime will be the first time that the cronLine will be effective from.
type RuntimeScheduleScanConfig struct {
	// CronLine Cron schedule expressions.
	CronLine *string `json:"cronLine,omitempty"`

	// OperationTime The next time this ScanConfig should trigger a scan.
	OperationTime *time.Time `json:"operationTime,omitempty"`
}

// SBOMConfig defines model for SBOMConfig.
type SBOMConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// SbomScan defines model for SbomScan.
type SbomScan struct {
	Packages *[]Package `json:"packages"`
}

// Scan Describes a multi-asset scheduled scan.
type Scan struct {
	// AssetIDs List of asset IDs to be scanned
	AssetIDs *[]string  `json:"assetIDs"`
	EndTime  *time.Time `json:"endTime,omitempty"`
	Id       *string    `json:"id,omitempty"`
	Revision *int       `json:"revision,omitempty"`

	// ScanConfig Describes a relationship to a scan config which can be expanded.
	ScanConfig *ScanConfigRelationship `json:"scanConfig,omitempty"`

	// ScanConfigSnapshot Snapshot of the configuration from the ScanConfig which created the
	// scan, so that changes in the ScanConfig do not affect the existing
	// Scan.
	ScanConfigSnapshot *ScanConfigSnapshot `json:"scanConfigSnapshot,omitempty"`
	StartTime          *time.Time          `json:"startTime,omitempty"`

	// State The lifecycle state of this scan.
	State *ScanState `json:"state,omitempty"`

	// StateMessage Human-readable message indicating details about the last state transition.
	StateMessage *string `json:"stateMessage,omitempty"`

	// StateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
	StateReason *ScanStateReason `json:"stateReason,omitempty"`

	// Summary A summary of the progress of a scan for informational purposes.
	Summary *ScanSummary `json:"summary,omitempty"`
}

// ScanState The lifecycle state of this scan.
type ScanState string

// ScanStateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
type ScanStateReason string

// ScanConfig Describes a multi-asset scheduled scan config.
type ScanConfig struct {
	// Disabled if true, the scan config is disabled and no scan should run from it
	Disabled *bool   `json:"disabled,omitempty"`
	Id       *string `json:"id,omitempty"`

	// MaxParallelScanners The maximum number of scanners that can run in parallel for each scan
	MaxParallelScanners *int    `json:"maxParallelScanners,omitempty"`
	Name                *string `json:"name,omitempty"`
	Revision            *int    `json:"revision,omitempty"`

	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig `json:"scanFamiliesConfig,omitempty"`

	// ScannerInstanceCreationConfig Configuration of scanner instance
	ScannerInstanceCreationConfig *ScannerInstanceCreationConfig `json:"scannerInstanceCreationConfig,omitempty"`

	// Scheduled Runtime schedule scan configuration. If only operationTime is set, it will be a single scan scheduled for the operationTime. If only cronLine is set, the current time will be the "from time" to start the scheduling according to the cronLine. If both operationTime and cronLine are set, the first scan will run at operationTime and the operationTime will be the first time that the cronLine will be effective from.
	Scheduled *RuntimeScheduleScanConfig `json:"scheduled,omitempty"`
	Scope     *string                    `json:"scope,omitempty"`

	// TimeoutSeconds The maximum time in seconds that a scan started from this config
	// should run for before being automatically aborted.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// ScanConfigExists defines model for ScanConfigExists.
type ScanConfigExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`

	// ScanConfig Describes a multi-asset scheduled scan config.
	ScanConfig *ScanConfig `json:"scanConfig,omitempty"`
}

// ScanConfigRelationship Describes a relationship to a scan config which can be expanded.
type ScanConfigRelationship struct {
	// Disabled if true, the scan config is disabled and no scan should run from it
	Disabled *bool  `json:"disabled,omitempty"`
	Id       string `json:"id"`

	// MaxParallelScanners The maximum number of scanners that can run in parallel for each scan
	MaxParallelScanners *int    `json:"maxParallelScanners,omitempty"`
	Name                *string `json:"name,omitempty"`
	Revision            *int    `json:"revision,omitempty"`

	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig `json:"scanFamiliesConfig,omitempty"`

	// ScannerInstanceCreationConfig Configuration of scanner instance
	ScannerInstanceCreationConfig *ScannerInstanceCreationConfig `json:"scannerInstanceCreationConfig,omitempty"`

	// Scheduled Runtime schedule scan configuration. If only operationTime is set, it will be a single scan scheduled for the operationTime. If only cronLine is set, the current time will be the "from time" to start the scheduling according to the cronLine. If both operationTime and cronLine are set, the first scan will run at operationTime and the operationTime will be the first time that the cronLine will be effective from.
	Scheduled *RuntimeScheduleScanConfig `json:"scheduled,omitempty"`
	Scope     *string                    `json:"scope,omitempty"`

	// TimeoutSeconds The maximum time in seconds that a scan started from this config
	// should run for before being automatically aborted.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// ScanConfigSnapshot Snapshot of the configuration from the ScanConfig which created the
// scan, so that changes in the ScanConfig do not affect the existing
// Scan.
type ScanConfigSnapshot struct {
	// Disabled if true, the scan config is disabled and no scan should run from it
	Disabled *bool `json:"disabled,omitempty"`

	// MaxParallelScanners The maximum number of scanners that can run in parallel for each scan
	MaxParallelScanners *int    `json:"maxParallelScanners,omitempty"`
	Name                *string `json:"name,omitempty"`

	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig `json:"scanFamiliesConfig,omitempty"`

	// ScannerInstanceCreationConfig Configuration of scanner instance
	ScannerInstanceCreationConfig *ScannerInstanceCreationConfig `json:"scannerInstanceCreationConfig,omitempty"`

	// Scheduled Runtime schedule scan configuration. If only operationTime is set, it will be a single scan scheduled for the operationTime. If only cronLine is set, the current time will be the "from time" to start the scheduling according to the cronLine. If both operationTime and cronLine are set, the first scan will run at operationTime and the operationTime will be the first time that the cronLine will be effective from.
	Scheduled *RuntimeScheduleScanConfig `json:"scheduled,omitempty"`
	Scope     *string                    `json:"scope,omitempty"`

	// TimeoutSeconds The maximum time in seconds that a scan started from this config
	// should run for before being automatically aborted.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// ScanConfigs defines model for ScanConfigs.
type ScanConfigs struct {
	// Count Total scan config count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of scan configs according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]ScanConfig `json:"items,omitempty"`
}

// ScanExists defines model for ScanExists.
type ScanExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`

	// Scan Describes a multi-asset scheduled scan.
	Scan *Scan `json:"scan,omitempty"`
}

// ScanFamiliesConfig The configuration of the scanner families within a scan config
type ScanFamiliesConfig struct {
	Exploits          *ExploitsConfig          `json:"exploits,omitempty"`
	Malware           *MalwareConfig           `json:"malware,omitempty"`
	Misconfigurations *MisconfigurationsConfig `json:"misconfigurations,omitempty"`
	Rootkits          *RootkitsConfig          `json:"rootkits,omitempty"`
	Sbom              *SBOMConfig              `json:"sbom,omitempty"`
	Secrets           *SecretsConfig           `json:"secrets,omitempty"`
	Vulnerabilities   *VulnerabilitiesConfig   `json:"vulnerabilities,omitempty"`
}

// ScanFindingsSummary A summary of the scan findings.
type ScanFindingsSummary struct {
	TotalExploits          *int `json:"totalExploits,omitempty"`
	TotalMalware           *int `json:"totalMalware,omitempty"`
	TotalMisconfigurations *int `json:"totalMisconfigurations,omitempty"`
	TotalPackages          *int `json:"totalPackages,omitempty"`
	TotalRootkits          *int `json:"totalRootkits,omitempty"`
	TotalSecrets           *int `json:"totalSecrets,omitempty"`

	// TotalVulnerabilities A summary of number of vulnerabilities found per severity.
	TotalVulnerabilities *VulnerabilityScanSummary `json:"totalVulnerabilities,omitempty"`
}

// ScanRelationship Describes an expandable relationship to Scan object
type ScanRelationship struct {
	// AssetIDs List of asset IDs to be scanned
	AssetIDs *[]string  `json:"assetIDs"`
	EndTime  *time.Time `json:"endTime,omitempty"`
	Id       string     `json:"id"`
	Revision *int       `json:"revision,omitempty"`

	// ScanConfig Describes a relationship to a scan config which can be expanded.
	ScanConfig *ScanConfigRelationship `json:"scanConfig,omitempty"`

	// ScanConfigSnapshot Snapshot of the configuration from the ScanConfig which created the
	// scan, so that changes in the ScanConfig do not affect the existing
	// Scan.
	ScanConfigSnapshot *ScanConfigSnapshot `json:"scanConfigSnapshot,omitempty"`
	StartTime          *time.Time          `json:"startTime,omitempty"`

	// State The lifecycle state of this scan.
	State *ScanRelationshipState `json:"state,omitempty"`

	// StateMessage Human-readable message indicating details about the last state transition.
	StateMessage *string `json:"stateMessage,omitempty"`

	// StateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
	StateReason *ScanRelationshipStateReason `json:"stateReason,omitempty"`

	// Summary A summary of the progress of a scan for informational purposes.
	Summary *ScanSummary `json:"summary,omitempty"`
}

// ScanRelationshipState The lifecycle state of this scan.
type ScanRelationshipState string

// ScanRelationshipStateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
type ScanRelationshipStateReason string

// ScanSummary defines model for ScanSummary.
type ScanSummary struct {
	JobsCompleted          *int `json:"jobsCompleted,omitempty"`
	JobsLeftToRun          *int `json:"jobsLeftToRun,omitempty"`
	TotalExploits          *int `json:"totalExploits,omitempty"`
	TotalMalware           *int `json:"totalMalware,omitempty"`
	TotalMisconfigurations *int `json:"totalMisconfigurations,omitempty"`
	TotalPackages          *int `json:"totalPackages,omitempty"`
	TotalRootkits          *int `json:"totalRootkits,omitempty"`
	TotalSecrets           *int `json:"totalSecrets,omitempty"`

	// TotalVulnerabilities A summary of number of vulnerabilities found per severity.
	TotalVulnerabilities *VulnerabilityScanSummary `json:"totalVulnerabilities,omitempty"`
}

// ScanType defines model for ScanType.
type ScanType string

// ScannerInstanceCreationConfig Configuration of scanner instance
type ScannerInstanceCreationConfig struct {
	MaxPrice         *string `json:"maxPrice,omitempty"`
	RetryMaxAttempts *int    `json:"retryMaxAttempts,omitempty"`
	UseSpotInstances bool    `json:"useSpotInstances"`
}

// ScannerMetadata defines model for ScannerMetadata.
type ScannerMetadata struct {
	ScannerName    *string         `json:"scannerName,omitempty"`
	ScannerSummary *ScannerSummary `json:"scannerSummary,omitempty"`
}

// ScannerSummary defines model for ScannerSummary.
type ScannerSummary struct {
	DataRead           *string `json:"DataRead,omitempty"`
	DataScanned        *string `json:"DataScanned,omitempty"`
	EngineVersion      *string `json:"EngineVersion,omitempty"`
	InfectedFiles      *int    `json:"InfectedFiles,omitempty"`
	KnownViruses       *int    `json:"KnownViruses,omitempty"`
	ScannedDirectories *int    `json:"ScannedDirectories,omitempty"`
	ScannedFiles       *int    `json:"ScannedFiles,omitempty"`
	SuspectedFiles     *int    `json:"SuspectedFiles,omitempty"`
	TimeTaken          *string `json:"TimeTaken,omitempty"`
}

// Scans defines model for Scans.
type Scans struct {
	// Count Total scans count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of scans according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]Scan `json:"items,omitempty"`
}

// Secret defines model for Secret.
type Secret struct {
	Description *string `json:"description,omitempty"`
	EndColumn   *int    `json:"endColumn,omitempty"`
	EndLine     *int    `json:"endLine,omitempty"`

	// FilePath Name of the file containing the secret
	FilePath *string `json:"filePath,omitempty"`

	// Fingerprint Note: this is not unique
	Fingerprint *string `json:"fingerprint,omitempty"`
	StartColumn *int    `json:"startColumn,omitempty"`
	StartLine   *int    `json:"startLine,omitempty"`
}

// SecretFindingInfo defines model for SecretFindingInfo.
type SecretFindingInfo struct {
	Description *string `json:"description,omitempty"`
	EndColumn   *int    `json:"endColumn,omitempty"`
	EndLine     *int    `json:"endLine,omitempty"`

	// FilePath Name of the file containing the secret
	FilePath *string `json:"filePath,omitempty"`

	// Fingerprint Note: this is not unique
	Fingerprint *string `json:"fingerprint,omitempty"`
	ObjectType  string  `json:"objectType"`
	StartColumn *int    `json:"startColumn,omitempty"`
	StartLine   *int    `json:"startLine,omitempty"`
}

// SecretScan defines model for SecretScan.
type SecretScan struct {
	Secrets *[]Secret `json:"secrets"`
}

// SecretsConfig defines model for SecretsConfig.
type SecretsConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// SecurityGroup general cloud security group
type SecurityGroup struct {
	Id string `json:"id"`
}

// SuccessResponse An object that is returned in cases of success that returns nothing.
type SuccessResponse struct {
	Message *string `json:"message,omitempty"`
}

// Tag general cloud tag / label
type Tag struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// VMInfo defines model for VMInfo.
type VMInfo struct {
	Image            string           `json:"image"`
	InstanceID       string           `json:"instanceID"`
	InstanceProvider *CloudProvider   `json:"instanceProvider,omitempty"`
	InstanceType     string           `json:"instanceType"`
	LaunchTime       time.Time        `json:"launchTime"`
	Location         string           `json:"location"`
	ObjectType       string           `json:"objectType"`
	Platform         string           `json:"platform"`
	SecurityGroups   *[]SecurityGroup `json:"securityGroups"`
	Tags             *[]Tag           `json:"tags"`
}

// VulnerabilitiesConfig defines model for VulnerabilitiesConfig.
type VulnerabilitiesConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// Vulnerability defines model for Vulnerability.
type Vulnerability struct {
	Cvss        *[]VulnerabilityCvss `json:"cvss"`
	Description *string              `json:"description,omitempty"`

	// Distro Distro provides information about a detected Linux distribution.
	Distro            *VulnerabilityDistro   `json:"distro,omitempty"`
	Fix               *VulnerabilityFix      `json:"fix,omitempty"`
	LayerId           *string                `json:"layerId,omitempty"`
	Links             *[]string              `json:"links"`
	Package           *Package               `json:"package,omitempty"`
	Path              *string                `json:"path,omitempty"`
	Severity          *VulnerabilitySeverity `json:"severity,omitempty"`
	VulnerabilityName *string                `json:"vulnerabilityName,omitempty"`
}

// VulnerabilityCvss defines model for VulnerabilityCvss.
type VulnerabilityCvss struct {
	Metrics *VulnerabilityCvssMetrics `json:"metrics,omitempty"`
	Vector  *string                   `json:"vector,omitempty"`
	Version *string                   `json:"version,omitempty"`
}

// VulnerabilityCvssMetrics defines model for VulnerabilityCvssMetrics.
type VulnerabilityCvssMetrics struct {
	BaseScore           *float32 `json:"baseScore,omitempty"`
	ExploitabilityScore *float32 `json:"exploitabilityScore,omitempty"`
	ImpactScore         *float32 `json:"impactScore,omitempty"`
}

// VulnerabilityDistro Distro provides information about a detected Linux distribution.
type VulnerabilityDistro struct {
	// IDLike the ID_LIKE field found within the /etc/os-release file
	IDLike *[]string `json:"IDLike"`

	// Name Name of the Linux distribution
	Name *string `json:"name,omitempty"`

	// Version Version of the Linux distribution (major or major.minor version)
	Version *string `json:"version,omitempty"`
}

// VulnerabilityFindingInfo defines model for VulnerabilityFindingInfo.
type VulnerabilityFindingInfo struct {
	Cvss        *[]VulnerabilityCvss `json:"cvss"`
	Description *string              `json:"description,omitempty"`

	// Distro Distro provides information about a detected Linux distribution.
	Distro            *VulnerabilityDistro   `json:"distro,omitempty"`
	Fix               *VulnerabilityFix      `json:"fix,omitempty"`
	LayerId           *string                `json:"layerId,omitempty"`
	Links             *[]string              `json:"links"`
	ObjectType        string                 `json:"objectType"`
	Package           *Package               `json:"package,omitempty"`
	Path              *string                `json:"path,omitempty"`
	Severity          *VulnerabilitySeverity `json:"severity,omitempty"`
	VulnerabilityName *string                `json:"vulnerabilityName,omitempty"`
}

// VulnerabilityFix defines model for VulnerabilityFix.
type VulnerabilityFix struct {
	State    *string   `json:"state,omitempty"`
	Versions *[]string `json:"versions"`
}

// VulnerabilityScan defines model for VulnerabilityScan.
type VulnerabilityScan struct {
	Vulnerabilities *[]Vulnerability `json:"vulnerabilities"`
}

// VulnerabilityScanSummary A summary of number of vulnerabilities found per severity.
type VulnerabilityScanSummary struct {
	TotalCriticalVulnerabilities   *int `json:"totalCriticalVulnerabilities,omitempty"`
	TotalHighVulnerabilities       *int `json:"totalHighVulnerabilities,omitempty"`
	TotalLowVulnerabilities        *int `json:"totalLowVulnerabilities,omitempty"`
	TotalMediumVulnerabilities     *int `json:"totalMediumVulnerabilities,omitempty"`
	TotalNegligibleVulnerabilities *int `json:"totalNegligibleVulnerabilities,omitempty"`
}

// VulnerabilitySeverity defines model for VulnerabilitySeverity.
type VulnerabilitySeverity string

// AssetID defines model for assetID.
type AssetID = string

// AssetScanID defines model for assetScanID.
type AssetScanID = string

// FindingID defines model for findingID.
type FindingID = string

// Ifmatch defines model for ifmatch.
type Ifmatch = int

// OdataCount defines model for odataCount.
type OdataCount = bool

// OdataExpand defines model for odataExpand.
type OdataExpand = string

// OdataFilter defines model for odataFilter.
type OdataFilter = string

// OrderBy defines model for odataOrderBy.
type OrderBy = string

// OdataSelect defines model for odataSelect.
type OdataSelect = string

// OdataSkip defines model for odataSkip.
type OdataSkip = int

// OdataTop defines model for odataTop.
type OdataTop = int

// ScanConfigID defines model for scanConfigID.
type ScanConfigID = string

// ScanID defines model for scanID.
type ScanID = string

// Success An object that is returned in cases of success that returns nothing.
type Success = SuccessResponse

// UnknownError An object that is returned in all cases of failures.
type UnknownError = ApiResponse

// GetAssetScansParams defines parameters for GetAssetScans.
type GetAssetScansParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetAssetScansAssetScanIDParams defines parameters for GetAssetScansAssetScanID.
type GetAssetScansAssetScanIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchAssetScansAssetScanIDParams defines parameters for PatchAssetScansAssetScanID.
type PatchAssetScansAssetScanIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutAssetScansAssetScanIDParams defines parameters for PutAssetScansAssetScanID.
type PutAssetScansAssetScanIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetAssetsParams defines parameters for GetAssets.
type GetAssetsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetAssetsAssetIDParams defines parameters for GetAssetsAssetID.
type GetAssetsAssetIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchAssetsAssetIDParams defines parameters for PatchAssetsAssetID.
type PatchAssetsAssetIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutAssetsAssetIDParams defines parameters for PutAssetsAssetID.
type PutAssetsAssetIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetFindingsParams defines parameters for GetFindings.
type GetFindingsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetFindingsFindingIDParams defines parameters for GetFindingsFindingID.
type GetFindingsFindingIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// GetScanConfigsParams defines parameters for GetScanConfigs.
type GetScanConfigsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetScanConfigsScanConfigIDParams defines parameters for GetScanConfigsScanConfigID.
type GetScanConfigsScanConfigIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchScanConfigsScanConfigIDParams defines parameters for PatchScanConfigsScanConfigID.
type PatchScanConfigsScanConfigIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutScanConfigsScanConfigIDParams defines parameters for PutScanConfigsScanConfigID.
type PutScanConfigsScanConfigIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// GetScansParams defines parameters for GetScans.
type GetScansParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetScansScanIDParams defines parameters for GetScansScanID.
type GetScansScanIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PatchScansScanIDParams defines parameters for PatchScansScanID.
type PatchScansScanIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PutScansScanIDParams defines parameters for PutScansScanID.
type PutScansScanIDParams struct {
	IfMatch *Ifmatch `json:"If-Match,omitempty"`
}

// PostAssetScansJSONRequestBody defines body for PostAssetScans for application/json ContentType.
type PostAssetScansJSONRequestBody = AssetScan

// PatchAssetScansAssetScanIDJSONRequestBody defines body for PatchAssetScansAssetScanID for application/json ContentType.
type PatchAssetScansAssetScanIDJSONRequestBody = AssetScan

// PutAssetScansAssetScanIDJSONRequestBody defines body for PutAssetScansAssetScanID for application/json ContentType.
type PutAssetScansAssetScanIDJSONRequestBody = AssetScan

// PostAssetsJSONRequestBody defines body for PostAssets for application/json ContentType.
type PostAssetsJSONRequestBody = Asset

// PatchAssetsAssetIDJSONRequestBody defines body for PatchAssetsAssetID for application/json ContentType.
type PatchAssetsAssetIDJSONRequestBody = Asset

// PutAssetsAssetIDJSONRequestBody defines body for PutAssetsAssetID for application/json ContentType.
type PutAssetsAssetIDJSONRequestBody = Asset

// PostFindingsJSONRequestBody defines body for PostFindings for application/json ContentType.
type PostFindingsJSONRequestBody = Finding

// PatchFindingsFindingIDJSONRequestBody defines body for PatchFindingsFindingID for application/json ContentType.
type PatchFindingsFindingIDJSONRequestBody = Finding

// PutFindingsFindingIDJSONRequestBody defines body for PutFindingsFindingID for application/json ContentType.
type PutFindingsFindingIDJSONRequestBody = Finding

// PostScanConfigsJSONRequestBody defines body for PostScanConfigs for application/json ContentType.
type PostScanConfigsJSONRequestBody = ScanConfig

// PatchScanConfigsScanConfigIDJSONRequestBody defines body for PatchScanConfigsScanConfigID for application/json ContentType.
type PatchScanConfigsScanConfigIDJSONRequestBody = ScanConfig

// PutScanConfigsScanConfigIDJSONRequestBody defines body for PutScanConfigsScanConfigID for application/json ContentType.
type PutScanConfigsScanConfigIDJSONRequestBody = ScanConfig

// PostScansJSONRequestBody defines body for PostScans for application/json ContentType.
type PostScansJSONRequestBody = Scan

// PatchScansScanIDJSONRequestBody defines body for PatchScansScanID for application/json ContentType.
type PatchScansScanIDJSONRequestBody = Scan

// PutScansScanIDJSONRequestBody defines body for PutScansScanID for application/json ContentType.
type PutScansScanIDJSONRequestBody = Scan

// AsVMInfo returns the union data inside the AssetType as a VMInfo
func (t AssetType) AsVMInfo() (VMInfo, error) {
	var body VMInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMInfo overwrites any union data inside the AssetType as the provided VMInfo
func (t *AssetType) FromVMInfo(v VMInfo) error {
	v.ObjectType = "VMInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMInfo performs a merge with any union data inside the AssetType, using the provided VMInfo
func (t *AssetType) MergeVMInfo(v VMInfo) error {
	v.ObjectType = "VMInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPodInfo returns the union data inside the AssetType as a PodInfo
func (t AssetType) AsPodInfo() (PodInfo, error) {
	var body PodInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPodInfo overwrites any union data inside the AssetType as the provided PodInfo
func (t *AssetType) FromPodInfo(v PodInfo) error {
	v.ObjectType = "PodInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePodInfo performs a merge with any union data inside the AssetType, using the provided PodInfo
func (t *AssetType) MergePodInfo(v PodInfo) error {
	v.ObjectType = "PodInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsDirInfo returns the union data inside the AssetType as a DirInfo
func (t AssetType) AsDirInfo() (DirInfo, error) {
	var body DirInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDirInfo overwrites any union data inside the AssetType as the provided DirInfo
func (t *AssetType) FromDirInfo(v DirInfo) error {
	v.ObjectType = "DirInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDirInfo performs a merge with any union data inside the AssetType, using the provided DirInfo
func (t *AssetType) MergeDirInfo(v DirInfo) error {
	v.ObjectType = "DirInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t AssetType) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"objectType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AssetType) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DirInfo":
		return t.AsDirInfo()
	case "PodInfo":
		return t.AsPodInfo()
	case "VMInfo":
		return t.AsVMInfo()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AssetType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AssetType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPackageFindingInfo returns the union data inside the Finding_FindingInfo as a PackageFindingInfo
func (t Finding_FindingInfo) AsPackageFindingInfo() (PackageFindingInfo, error) {
	var body PackageFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided PackageFindingInfo
func (t *Finding_FindingInfo) FromPackageFindingInfo(v PackageFindingInfo) error {
	v.ObjectType = "Package"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided PackageFindingInfo
func (t *Finding_FindingInfo) MergePackageFindingInfo(v PackageFindingInfo) error {
	v.ObjectType = "Package"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsVulnerabilityFindingInfo returns the union data inside the Finding_FindingInfo as a VulnerabilityFindingInfo
func (t Finding_FindingInfo) AsVulnerabilityFindingInfo() (VulnerabilityFindingInfo, error) {
	var body VulnerabilityFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnerabilityFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided VulnerabilityFindingInfo
func (t *Finding_FindingInfo) FromVulnerabilityFindingInfo(v VulnerabilityFindingInfo) error {
	v.ObjectType = "Vulnerability"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnerabilityFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided VulnerabilityFindingInfo
func (t *Finding_FindingInfo) MergeVulnerabilityFindingInfo(v VulnerabilityFindingInfo) error {
	v.ObjectType = "Vulnerability"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMalwareFindingInfo returns the union data inside the Finding_FindingInfo as a MalwareFindingInfo
func (t Finding_FindingInfo) AsMalwareFindingInfo() (MalwareFindingInfo, error) {
	var body MalwareFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMalwareFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided MalwareFindingInfo
func (t *Finding_FindingInfo) FromMalwareFindingInfo(v MalwareFindingInfo) error {
	v.ObjectType = "Malware"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMalwareFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided MalwareFindingInfo
func (t *Finding_FindingInfo) MergeMalwareFindingInfo(v MalwareFindingInfo) error {
	v.ObjectType = "Malware"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsSecretFindingInfo returns the union data inside the Finding_FindingInfo as a SecretFindingInfo
func (t Finding_FindingInfo) AsSecretFindingInfo() (SecretFindingInfo, error) {
	var body SecretFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecretFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided SecretFindingInfo
func (t *Finding_FindingInfo) FromSecretFindingInfo(v SecretFindingInfo) error {
	v.ObjectType = "Secret"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecretFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided SecretFindingInfo
func (t *Finding_FindingInfo) MergeSecretFindingInfo(v SecretFindingInfo) error {
	v.ObjectType = "Secret"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMisconfigurationFindingInfo returns the union data inside the Finding_FindingInfo as a MisconfigurationFindingInfo
func (t Finding_FindingInfo) AsMisconfigurationFindingInfo() (MisconfigurationFindingInfo, error) {
	var body MisconfigurationFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMisconfigurationFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided MisconfigurationFindingInfo
func (t *Finding_FindingInfo) FromMisconfigurationFindingInfo(v MisconfigurationFindingInfo) error {
	v.ObjectType = "Misconfiguration"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMisconfigurationFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided MisconfigurationFindingInfo
func (t *Finding_FindingInfo) MergeMisconfigurationFindingInfo(v MisconfigurationFindingInfo) error {
	v.ObjectType = "Misconfiguration"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRootkitFindingInfo returns the union data inside the Finding_FindingInfo as a RootkitFindingInfo
func (t Finding_FindingInfo) AsRootkitFindingInfo() (RootkitFindingInfo, error) {
	var body RootkitFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRootkitFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided RootkitFindingInfo
func (t *Finding_FindingInfo) FromRootkitFindingInfo(v RootkitFindingInfo) error {
	v.ObjectType = "Rootkit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRootkitFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided RootkitFindingInfo
func (t *Finding_FindingInfo) MergeRootkitFindingInfo(v RootkitFindingInfo) error {
	v.ObjectType = "Rootkit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsExploitFindingInfo returns the union data inside the Finding_FindingInfo as a ExploitFindingInfo
func (t Finding_FindingInfo) AsExploitFindingInfo() (ExploitFindingInfo, error) {
	var body ExploitFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExploitFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided ExploitFindingInfo
func (t *Finding_FindingInfo) FromExploitFindingInfo(v ExploitFindingInfo) error {
	v.ObjectType = "Exploit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExploitFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided ExploitFindingInfo
func (t *Finding_FindingInfo) MergeExploitFindingInfo(v ExploitFindingInfo) error {
	v.ObjectType = "Exploit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Finding_FindingInfo) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"objectType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Finding_FindingInfo) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "Exploit":
		return t.AsExploitFindingInfo()
	case "Malware":
		return t.AsMalwareFindingInfo()
	case "Misconfiguration":
		return t.AsMisconfigurationFindingInfo()
	case "Package":
		return t.AsPackageFindingInfo()
	case "Rootkit":
		return t.AsRootkitFindingInfo()
	case "Secret":
		return t.AsSecretFindingInfo()
	case "Vulnerability":
		return t.AsVulnerabilityFindingInfo()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Finding_FindingInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Finding_FindingInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
